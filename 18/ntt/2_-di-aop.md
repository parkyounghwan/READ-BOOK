# 2\_스프링 코어\(DI, AOP\)

> p15-128

## 2.1. DI

* 의존성 주입\(Dependency Injection\)

하나의 처리를 수행하기 위해 여러 개의 컴포넌트를 통합할 때. 각 컴포넌트의 인스턴스를 생성하고 통합 관리

어떤 컴포넌트는 싱글턴 객체로 만들어야 하고 어떤 컴포넌트는 프로토타입 객체로 만들어야 하는 등의 스코프 관리

각 인스턴스가 필요로 하는 공통 처리 코드를 외부에서 자동으로 끼워넣는 AOP 기능

들을 DI 컨테이너가 대신 해줌

* IoC 디자인 패턴

인스턴스를 제어하는 주도권이 역전된다는 의미. 컴포넌트를 구성하는 인스턴스의 생성과 의존 관계의 연결 처리를 해당 소스코드가 아닌 DI 컨테이너에서 대신해주기 때문에 제어가 역전되었다고 한다.

## 2.1.2. ApplicationContext와 빈 정의

@Configuration과 @Bean 애너테이션을 사용해서 DI 컨테이너에 컴포넌트를 등록하면 애플리케이션은 DI컨테이너에서 있는 빈을 ApplicationContext 인스턴스를 통해 가져올 수 있다.

DI 컨테이너에 등록하는 컴포넌트를 빈이라고 하고, 이 빈에대한 설정 정보를 '빈 정의'라고 한다. DI 컨테이너에서 빈을 찾아오는 행위를 '룩업'이라고 한다.

## 2.1.3. 빈 설정

* 자바 기반 설정 방식 / XML 기반 설정 방식

자바 코드 / XML로 빈을 설정. 애플리케이션에서 사용되는 모든 컴포넌트를 빈으로 정의해야한다.

* 애너테이션 기반 설정 방식

빈을 정의하는 애너테이션을 빈의 클래스에 부여한다. 이후 애너테이션이 붙은 클래스를 탐색해서 DI 컨테이너에 자동으로 등록한다\(Component Scan\). 또한 의존성 주입도 애너테이션이 붙어있으면 자동으로 주입하게 한다\(Auto Wiring\).

컴포넌트 스캔을 수행할 때는 스캔할 범위를 지정한다.

DI 컨테이너에 등록되는 빈의 이름은 클래스명의 첫 글자를 소문자로 바꾼 이름과 같다.명시적으로 빈의 이름을 지정하고 싶다면 @Component\(""\)에 원하는 이름을 넣어주면 된다.

## 2.1.4. 의존성 주입

* 설정자 기반 의존성 주입 방식

설정자 메서드의 인수를 통해 의존성을 주입하는 방식이다. 세터 인젝션이라고 부른다.

애너테이션 기반 설정 방식으로 표현하면, 설정자 메서드에 @Autowired 애너테이션을 달아주기만 하면 된다. 자바나 XML 기반 설정 방식 등의 별도의 설정 파일을 둘 필요가 없다.

* 생성자 기반 의존성 주입 방식

생성자의 인수를 사용해 의존성을 주입하는 방식이다. 컨스트럭터 인젝션이라고 부른다.

애너테이션 기반 설정 방식에서는 생성자에 @Autowired를 부여한다.

필드를 final로 선언해서 생성 후에 변경되지 않게 만들 수 있다.

* 필드 기반 의존성 주입 방식

생성자나 설정자 메서드를 쓰지 않고 DI 컨테이너의 힘을 빌려 의존성을 주입하는 방식이다. 필드 인젝션이라고 부른다.

의존성을 주입하고 싶은 필드에 @Autowired 애너테이션을 달아주면 된다.

DI 컨테이너 없이 사용되는 독립형 라이브러리로 사용될 소스코드에서 필드 인젝션을 사용하고 있다면 잘못된 것이라고 판단해야 한다.

## 2.1.5. 오토와이어링

빈을 정의하지 않고도 DI 컨테이너에 빈을 자동으로 주입하는 방식이다.

* 타입으로 오토와이어링하기 \(autowiring by type\)

세터 인젝션, 컨스트럭터 인젝션, 필드 인젝션의 세 가지 의존성 주입 방법에서 모두 활용할 수 있다. 기본적으로 의존성 주입이 반드시 성공한다고 가정한다.

그래서 주입할 타입에 해당하는 빈을 DI 컨테이너 안에서 찾지 못한다면 NoSuchBeanDefinitionException이라는 예외가 발생한다. 이러한 필수 조건을 완화하고 싶다면 required 속성에 false를 설정하면 된다. 의존성 주입이 실패하고 해당 필드의 값은 null이 된다.

한편 같은 타입의 빈이 여러 개 발견된다면, NoUniqueBeanDefinitionException이 발생한다. @Qualifier 애너테이션으로 빈 이름을 지정하면 원하는 빈만 선택할 수 있다. 또는 @Primary로 우선적으로 선택될 빈을 지정할 수 있다.

* 이름으로 오토와이어링하기 \(autowiring by name\)

@Qualifier를 @Resource로 대체한다. 이 때 @Resource의 name 속성을 생략할 수 있다. 빈의 이름이 필드명이나 프로퍼티명과 일치할 경우에 빈 이름으로 필드 인젝션을 하는 방법이다. 세터 인젝션을 하는 경우에는 프로퍼티 이름과 같은 이름의 빈이 선택된다.

위의 어느 경우에도 해당되지 않으면 타입으로 오토와이어링을 시도한다. 컨스트럭터 인젝션에서는 @Resource를 사용할 수 없다.

* 컬렉션이나 맵 타입으로 오토와이어링하기

단 하나의 빈만 가져오는 방법 외에도 같은 인터페이스를 구현한 빈을 컬렉션이나 맵 타입에 담아서 가져오는 방법도 제공한다.

## 2.1.6. 컴포넌트 스캔

컴포넌트 스캔은 클래스 로더를 스캔하면서 특정 클래스를 찾은 다음, DI 컨테이너에 등록하는 방법을 말한다.

대표적인 스캔대상 애너테이션: `@Controller` `@Service` `@Repository` `@Component`

## 2.1.7. 빈 스코프

DI 컨테이너는 빈 간의 의존 관계를 관리할 뿐만 아니라 빈의 생존 기간도 관리한다. 빈의 생존 기간을 빈 스코프\(bean scope\)라고 하는데 개발자가 직접 빈의 스코프를 다루지 않아도 된다는 점은 DI 컨테이너를 사용하는 큰 이유이기도 하다.

빈 스코프를 관리하는 구현 코드는 상당히 중요한 부분이지만, 비즈니스 관점에서는 본질과는 동떨어진 관심 밖의 내용이다. 그래서 이러한 코드가 많으면 많을수록 애플리케이션 전체를 이해하기 어려워지고 기능을 예측할 수 없게 된다.

스프링 프레임워크에는 빈 스코프를 관리하는 기능이 있기 때문에 DI 컨테이너에 맡길 수 있다. 이 빈은 기본적으로 싱글턴으로 만들어진다. `context.getBean(*.class);`로 가져올 수 있다.

* 스코프 설정

DI 컨테이너에서 빈을 가져오려 할 때 같은 것이 없으면 새로 만들고, 같은 것이 있으면 이미 만들어진 것을 공유한다. DI 컨테이너가 파괴될 때 그 안에 있던 빈도 파괴된다.

만약 기본 스코프 외 다른 스코프로 빈을 사용하고 싶다면 빈을 정의하는 단계에서 스코프를 명시한다.

자바 기반의 설정 방식에서는 @Bean 애너테이션이 붙은 메서드에 @Scope 애너테이션을 추가해서 스코프를 명시한다.

애너테이션 기반 방식에서는 스캔 대상이 되는 클래스에 @Scope 애너테이션을 추가해서 스코프를 명시한다.

* 다른 스코프의 빈 주입

스코프는 빈의 생존 기간을 의미한다. 빈 간의 스코프가 서로 다르다는 말은 곧 각 빈의 수명이 다르다는 말이기도 하다. 예를 들어, singleton 스코프가 prototype 스코프보다 더 오래 산다.

DI 컨테이너에서 빈 간의 의존 관계가 형성되는데, 만약 하나의 빈이 또 다른 빈에 의존하고 있다면 DI 컨테이너에 의해 주입된 빈은 자신의 스코프와 상관없이 주입받는 빈의 스코프를 따르게 된다.

해결 방법 -&gt; 빈을 주입하지 않음 / 룩업 메서드 인젝션 / 스코프트 프락시 / 커스텀 스코프 만들기

## 2.1.8. 빈의 생명 주기

1. 빈 초기화 단계\(initialization\)

   빈을 설정 -&gt; 빈을 인스턴스화하고 의존성을 주입 -&gt; 빈을 생성한 다음의 후처리

2. 빈 사용 단계\(activation\)
3. 빈 종료 단계\(destruction\)

   빈이 파괴되기 전에 전처리 \(빈 생성 후의 초기화 구조와 대칭되지만 정반대로 동작\)

## 2.2. AOP

소프트웨어를 개발할 때 소스코드의 규모가 커지다 보면 로깅이나 캐시와 같이 비즈니스 로직과는 크게 관련 없는 처리 내용이 소스코드의 여기저기에 산재하기 쉽다. 이런 코드가 많아지면 DRY\(Do not Repeat Yourself\) 원칙에 어긋나고, 향후 발생할 수 있는 변경에도 취약하다.

이렇게 구현하고자 하는 비즈니스 로직과는 다소 거리가 있으나 여러 모듈에 걸쳐 공통적이고 반복적으로 필요로 하는 처리 내용을 횡단 관심사\(Cross-Cutting Concern\)라고 부른다. 대표적인 횡단 관심사에는 &lt;보안, 로깅, 트랜잭션 관리, 모니터링, 캐시 처리, 예외 처리&gt; 가 있다.

프로그램 안에서 이를 한 곳으로 모으는 것을 횡단 관심사의 분리\(Separation Of Cross-Cutting Concerns\)라 하고, 이를 실현하는 방법을 관점 프로그래밍이라 한다.

## 2.2.1. AOP의 개요

AOP는 관점 지향 프로그래밍\(Aspect Oriented Programming\)을 의미하는 약자로, 여러 클래스에 흩어져 있는 횡단 관심사를 중심으로 설계와 구현을 하는 프로그래밍 기법이다.

DI를 활용해 클래스의 인스턴스를 생성하고, 인스턴스 간의 의존 관계를 맺는 처리를 애플리케이션 코드에서 분리했다. AOP를 활용하면 이 인스턴스들이 필요로 하는 공통적인 기능을 외부에서 집어넣을 수 있게 된다. 애플리케이션 코드에서 공통적인 기능을 분리해 내는 것이라고 할 수 있다.

대표적인 용어

* 애스펙트\(Aspect\) : AOP의 예로 자주 언급되는 '로그를 출력한다', '예외를 처리한다', '트랜잭션을 관리한다'와 같은 관심사가 애스팩트다.
* 조인 포인트\(Join Point\) : 횡단 관심사가 실행될 지점이나 시점\(메서드 실행이나 예외 발생 등\)을 말한다.
* 어드바이스\(Advice\) : 특정 조인 포인트에서 실행되는 코드로, 횡단 관심사를 실제로 구현해서 처리하는 부분이다.
* 포인트컷\(Pointcut\) : 수많은 조인 포인트 중에서 실제로 어드바이스를 적용할 곳을 선별하기 위한 표현식을 말한다. 일종의 조인 포인트의 그룹이라 볼 수도 있다.
* 위빙\(Weaving\) : 애플리케이션 코드의 적절한 지점에 애스펙트를 적용하는 것을 말한다. AOP 구현 라이브러리에 따라 위빙하는 시점이 다를 수 있다. 스프링 AOP는 기본적으로 실행 시점에 위빙한다.
* 타깃\(Target\) : AOP 처리에 의해 처리 흐름에 변화가 생긴 객체를 말한다. 어드바이스드 오브젝트라고도 한다.

## 2.2.2. 스프링 AOP

DI 컨테이너에서 관리하는 빈들을 타깃으로 어드바이스를 적용하는 기능이 있는데, 조인 포인트에 어드바이스를 적용하는 방법은 프락시 객체를 만들어서 대체하는 방법을 쓴다. 그래서 어드바이스가 적용된 이후, DI 컨테이너에서 빈을 꺼내보면 원래 있던 빈 인스턴스가 아니라 프락시 형태로 어드바이스 기능이 덧입혀진 빈이 나온다.

스프링 AOP에는 실제 개별 현장에서 폭넓게 사용돼온 AspectJ라는 AOP 프레임워크가 포함돼 있다. AspectJ는 애스펙트와 어드바이스를 정의하기 위한 애너테이션이나 포인트컷 표현 언어, 위빙 메커니즘 등을 제공하는 역할을 한다. 참고로 AspectJ에서는 컴파일할 때, 클래스를 로드할 때, 실행할 때와 같이 다양한 위빙 시점을 지원하지만 스프링 AOP는 이 가운데 실행 시점의 위빙을 기본으로 지원한다. 그래서 컴파일이나 클래스 로드 시점에 위빙을 하기 위한 추가적인 설정을 따로 하지 않아도 된다.

## 2.2.6. 스프링 프로젝트에서 활용되는 AOP 기능

* 트랜잭션 관리

@Transactional 애너테이션을 통해 복잡한 트랜잭션 관리를 스프링에게 맡길 수 있다. 해당 메서드가 정상적으로 종료한 것이 확인되면 트랜잭션을 커밋하고, 예외가 발생하면 감지하여 트랜잭션을 롤백한다.

* 인가

권한 제어가 필요한 메서드에 @PreAuthorize 애너테이션을 지정하면 해당 메서드가 호출되기 전에 특정 인가 조건을 만족하는지 확인할 수 있다.

* 캐싱

@Cacheable 메서드의 매개변수 등을 키로 사용해 메서드의 실행 결과를 캐시로 관리할 수 있다.

* 비동기 처리

@Async를 사용하고 반환값으로 CompletableFuture 타입의 값이나 DeferredResult 타입의 값을 반환하게 만들면 AOP방식의 별도 스레드에서 실행된다.

* 재처리

@Retryable 해당 메서드가 정상적으로 처리되지 않은 경우, 원하는 조건을 만족할 때까지 재처리하게 된다. 신뢰성을 보장하기 어려운 외부 시스템과 연계해야 할 때 상당히 유용하다.

## 2.3. 데이터 바인딩과 형 변환

자바 객체의 프로퍼티에 외부에서 입력된 값을 설정하는 과정을 데이터 바인딩이라 한다. 앞서 DI 컨테이너에서 관리되면서 애플리케이션을 구성하는 컴포넌트 역할의 자바 객체를 '빈'이라고 불렀다. 이제부터는 데이터 바인딩이나 프로퍼티 관점에서 다뤄지는 객체를 '자바빈즈'라고 좀 더 구체적으로 언급한다.

프로퍼티의 입력값으로 사용되는 값은 웹 애플리케이션의 요청 파라미터, 프로퍼티 파일의 설정 값, XML 기반 설정에서 빈을 정의할 때 지정한 프로퍼티 값과 같은 다양한 형태가 있는데, 그중에서도 가장 대표적인 것은 웹 애플리케이션에 사용하는 요청 파라미터일 것이다.

스프링에서는 HTTP 요청 파라미터 값을 자바빈즈의 프로퍼티로 설정하는 과정을 쉽게 할 수 있도록 여러 방법을 제공해 준다.

## 2.4. 프로퍼티 관리

애플리케이션이 사용하는 각종 설정 값을 어떻게 읽어와서 사용하는지 살펴보자.

데이터베이스에 접근하기 위한 Datasource 역할을 하는 dataSource 빈이 있다. 이 코드에는 데이터베이스에 접속할 때 필요한 각종 정보가 설정돼있다. 이렇게 정의된 빈은 DI 컨테이너에 등록되는데, 이때 데이터베이스 URL이나 사용자명, 패스워드와 같은 환경에 의존적인 정보도 함께 들어가게 된다. 이렇게 되면 향후 데이터 접속 대상이 바뀔 때마다 빈을 다시 정의해야 하고 그로 인해 디플로이나 운영 작업이 복잡하고 번거로워질 수 있다. 스프링은 이러한 상황을 최소화할 수 있도록 각종 설정 정보를 효율적으로 다룰 수 있는 관리 메커니즘을 제공한다.

빈 정의 시 또는 빈 구현 과정에서 프로퍼티 활용 -&gt; @Value 애너테이션을 통해 값을 주입한다.

## 2.6. 리소스 추상화

애플리케이션을 개발할 때는 설정 파일과 같은 다양한 리소스를 필요로 한다. 스프링에서는 구체적인 위치 정보를 직접 다루지 않더라도 리소스에 접근할 수 있다.

기본적으로 Resource 인터페이스 객체를 제공한다. 이 객체를 생성하는 과정을 추상화하기 위해 ResourceLoader 인터페이스를 제공한다. DI 컨테이너를 구성하는 다양한 ApplicationContext 인터페이스의 구현 클래스는 모두 이 인터페이스를 구현하고 있다.

Resource 객체를 가져오려면 getResource 메서드의 매개변수로 리소스의 위치를 지정하면 된다. 만약 클래스패스 상의 리소스를 지정해야 한다면 경로 앞에 'classpath:'와 같은 접두어가 붙는다. 결국 ResourceLoader 인터페이스의 구현 클래스는 리소스의 경로 정보를 보고 이에 맞는 Resource 인터페이스의 구현 클래스를 선택하게 된다.

주의해야 하는 것은 파일 경로 형식을 사용할 때 ApplicationContext의 종류에 따라 파일 경로를 읽는 방식이 달라질 수 있다는 점이다. 예를 들면, ClassPathXmlApplicationContext 클래스는 리소스 경로를 클래스패스 상의 상대 경로로 인식한다. 반면 WebApplicationContext 인터페이스의 구현 클래스는 리소스 경로를 웹 애플리케이션의 루트 디렉터리를 기준으로 한 상대 경로로 인식한다. 만약 이 차이를 간과한다면 서버에 디플로이했을 때 파일을 못 읽는 오류가 발생할 수 있다. 이를 방지하기 위해 애당초 리소스의 경로에 'classpath:'를 붙여두는 것을 권장한다.

