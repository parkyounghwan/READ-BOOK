# 2-4

> p39-170

## 2. 자바와 절차적/구조적 프로그래밍 \|p39-75

* 함수와 메서드는 무엇이 다르냐? 전혀 다르지 않다.

절차적/구조적 프로그래밍에서 함수라 불렀는데 객체 지향에서는 좀 다르게 불러야 하지 않을까? 해서 메서드라고 불렀다고 한다.

굳이 차이점을 찾자면 함수는 클래스나 객체와 아무 관계가 없지만, 메서드는 반드시 클래스 정의 안에 존재해야 한다. 객체 지향 언어에서 클래스 외부에 존재할 수 있는 것은 없다. import 구문은 편의 기능일 뿐이다.

* 객체 지향 프로그램의 메모리 사용 방식 \(데이터 영역\)

  | 스태틱 영역 |  |
  | :--- | :--- |
  | 스택 영역 | 힙 영역 |

* main\(\) 메서드: 메서드 스택 프레임

main\(\) 메서드는 프로그램이 실행되는 시작점이다.

```java
public class Start {
    public static void main(String[] args) {
        System.out.println("Hello OOP!");
    }
}
```

1. JRE는 프로그램 안에 main\(\) 메서드가 있는지 확인한다. Start 클래스에서 찾을 수 있다.
2. JVM은 전처리를 한다.

   main\(\) 존재가 확인되면 프로그램 실행을 위해 준비한다. JVM에 전원을 넣어 부팅하고 목적 파일을 받아 실행한다.

   모든 자바 프로그램이 반드시 포함하게 되는 java.lang 패키지를 T 메모리의 스태틱 영역에 갖다 놓는다.

   개발자가 작성한 모든 클래스와 임포트 패키지도 스태틱 영역에 갖다 놓는다.

3. 클래스 정의를 시작하는 여는 중괄호를 제외하고, 모든 여는 중괄호를 만날 때 메서드가 스택 프레임에 할당된다.

   메서드의 인자 args를 저장할 변수 공간을 스택 프레임 내에 할당한다.

4. 메서드의 첫 명령문을 실행한다. \(위 코드에서 Sysout\)
5. 메서드의 끝을 나타내는 닫는 중괄호를 만나면 스택 프레임이 소멸된다.
6. 끝나면 JRE는 JVM을 종료하고 JRE도 운영체제의 메모리에서 사라진다. T 메모리도 사라진다.
7. 메모리, 변수, 블록

```java
public class Start2 {
    public static void main(String[] args) {
        int i;
        i = 10;
        double d = 20.0;
        if (i == 10) {
            int m = i + 5;
        }
    }
}
```

`int i` i에는 어떤 값이 저장돼있을까? 알 수 없는 값이 들어가 있다. 이전에 해당 공간의 메모리를 사용했던 다른 프로그램이 청소하지 않고 간 값, 쓰레기값을 가지고 있다.

`int m`

if 블록이 열릴 때 스택 영역에 생성되고 닫힐 때 소멸된다.

`뒤쪽에 나오는 얘기지만 변수 얘기할 때 같이 쓰는 멤버 변수`

클래스/객체 속성은 별도 초기화를 해주지 않아도 알아서 자료형에 알맞는 초기화를 해준다. 멤버 변수는 공유 변수의 성격을 가지고 있기 때문이다.

* 스택 프레임에 종속적인 지역 변수

변수는 스태틱, 스택, 힙 영역 각각에 존재하고 다른 목적을 가진다. 각각의 이름도 다르다.

| 이름 | 다른 이름 | 사는 곳 |
| :--- | :--- | :--- |
| 스태틱 변수 | 클래스 \[멤버\] 속성, 정적 변수 | 스태틱 영역 |
| 인스턴스 변수 | 객체 \[멤버\] 속성, 객체 변수 | 힙 영역 |
| 로컬 변수 | 지역 변수 | 스택 영역\(스택 프레임 내부\) |

스택 영역 - 지역 변수 - 스택 프레임 안에서 생성\(지역 내\)되며 스택 프레임 소멸시\(지역이 사라지면\) 함께 소멸된다.

스태틱 영역 - 클래스 멤버 변수 - JVM이 종료될 때까지 고정된\(static\) 상태로 있다.

힙 영역 - 객체 멤버 변수 - 객체와 함께 가비지 컬렉터에 의해 소멸된다.

두 메서드 사이에서 값을 전달할 때 1. 호출할 때 메서드의 인자를 이용 2. 메서드를 종료할 때 반환값을 넘겨주기 -&gt; 이 때 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만을 복제해서 전달한다. Call By Value.

* 스택 프레임에 독립적인 전역 변수 \(공유 변수\)

클래스 내의 static 키워드가 붙은 변수는 해당 클래스가 T 메모리의 스태틱 영역에 배치될 때, 같은 시점에 스태틱 영역에 변수 공간이 할당된다.

전역 변수는 메서드들 사이에서 공유해서 사용할 수 있다.

* 멀티 스레드

멀티 스레드는 T 메모리 모델에서 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다. 스택 영역만 분할하므로 다른 스레드의 스택 영역에 접근할 수는 없지만 스태틱, 힙 영역은 공유한다. 멀티 프로세스보다 메모리를 적게 사용한다.

두 개의 스레드에서 전역 변수 사용 시 문제점

1. 스레드1에서 공유 영역의 전역 변수 A에 10을 할당했다. 
2. 스레드2에서 변수 A에 20을 할당했다. 
3. 스레드1에서도 A의 값은 갑자기 20이 되어있다.

이를 보완하는 방법으로 락이 있지만 그 순간 스레드의 장점은 사라진다.

* 멀티 프로세스

다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조이다. 각 프로세스마다 각자의 T 메모리가 있는 고유 공간이므로 서로 참조할 수 없다. 그래서 안전하지만 메모리 사용량이 크다.

+\) 자바 서블릿은 요청당 프로세스가 아닌 요청당 스레드를 생성한다. 위와 같은 맥락에서 요청당 스레드가 더 효율적이다.

## 3. 자바와 객체 지향 \|p82-143

99p 질문

* 객체 지향의 이해

객체는 사물이다. 유일무이하다.

클래스는 같은 특성을 지닌 여러 객체를 총칭하는 집합이다.

* 변수 네이밍

객체 참조 변수 이름도 고민해서 지을 것. 객체 참조 변수는 결국 객체를 참조하게 되는데 객체는 유일무이한 것이기 때문. 클래스명은 _분류_스럽게, 객체 참조 변수명은 _유일무이한 사물_처럼 작명할 것.

* 추상화: 모델링

`Mouse mickey = new Mouse();`

태어난 한 마리의 쥐 이름을 mickey라 하였다.

쥐-클래스 / 한마리 쥐-클래스의 인스턴스\(객체\) / mickey-객체 참조 변수

* 클래스 멤버 vs 객체 멤버 = static\(정적\) 멤버 vs 인스턴스 멤버

`public static int tail = 1;` 쥐의 꼬리는 몇 개?

Mouse의 각 객체들이 모두 같은 값을 갖는 꼬리 값의 변수라고 생각해보자.

각각의 객체에 따로 저장하지 않고 한 곳에만 저장해도 좋을 것 같다. 이럴 때 클래스에 저장할 수 있는데, 스태틱 영역에 단 하나의 저장 공간을 갖게 된다.

static이 붙은 속성/메서드는 클래스 내에서 값을 공유한다. 그래서 클래스 멤버 속성/메서드 라고 한다. 이외의 객체\(인스턴스\) 내에서의 속성/메서드는 객체 멤버 속성/메서드 라고 한다.

* 같은 말 퍼레이드 클래스 = 정적 = 스태틱 멤버 객체 = 오브젝트 = 인스턴스 멤버 필드 = 속성 = 프로퍼티 함수 = 메서드 변수 공간 = 메모리 공간
* 상속: 재사용 + 확장

상속이라는 것은 inheritance보다 extends에 가깝다.

상위 클래스에서 구현한 showMe\(\) 메서드를 모든 하위 클래스 객체에서 사용할 수 있다. 클래스 상속 구조에서 최상위 클래스는 Object이다. 그래서 모든 클래스는 결국 Object의 특성을 물려받는다. 그래서 어떤 클래스의 인스턴스이든 toString\(\) 메서드를 사용할 수 있다.

-&gt; 재사용, 확장, is a kind of 관계

하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다. \(모든 클래스의 최상의 클래스인 Object도 생성된다.\)

만약 객체 참조 변수가 가리키고 있는 것이 상위 클래스일 경우, 하위 클래스의 인스턴스는 사용할 수 없다.

* 인터페이스

다중 상속 대신 인터페이스를 도입하였다. 인터페이스는 상속과는 다르게 쓰는 것이 유용하다.

be able to, 무엇을 할 수 있는 형태의 예시를 볼 수 있다.

Serializable: 직렬화할 수 있는 Cloneable: 복제할 수 있는 Comparable: 비교할 수 있는 Runnable: 실행할 수 있는

+\) 상위 클래스는 하위 클래스에게 물려줄 특성이 풍성할수록 좋다. \(LSP\) 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다. \(ISP\)

* 다형성: 사용편의성

오버라이딩 - 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의. 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩한 메서드가 호출된다.

오버로딩 - 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

* 캡슐화: 정보 은닉

접근 제어자인 private, \[default\], protected, public.들이 객체 멤버와 쓰일 때와 정적 멤버와 쓰일 때를 비교한다.

* 접근 제어자와 객체 멤버

public - 모두가 접근 가능

protected - 상속/같은 패키지 내의 클래스에서 접근 가능

\[default\] - 같은 패키지 내의 클래스에서 접근 가능

private - 본인만 접근 가능

상속을 받지 않은 다른 객체의 멤버에 접근하는 경우에는 다른 객체를 생성한 후 접근해야 한다.

객체를 생성한 경우에는 객체참조변수명.정적멤버 형태로도 접근할 수 있다. 다만 정적 멤버는 클래스형.정적멤버 형식으로 접근하는 것을 권장한다. 일관된 형식으로 접근하기 위해서이다.

* 참조 변수의 복사

기본 자료형 변수를 복사하는 경우 Call By Value에 의해 복사되며 두 변수는 서로에게 영향을 주지 않는다.

```java
int a = 10;
int b = a;

b = 20;

// a: 10
// b: 20
```

객체를 저장하고 있는 객체 참조 변수는 Call By Reference에 의해 복사되며 같은 객체를 참조한다.

```java
Animal ref_a = new Animal();
Animar ref_b = ref_a;

ref_a.age = 10;
ref_b.age = 20;

// a: 20
// b: 20
```

## 4. 자바가 확장한 객체 지향 \|p146-170

* abstract - 추상 메서드와 추상 클래스

선언부는 있는데 구현부가 없는 메서드를 말한다. 추상 메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스로 선언해야 한다. 그런데 추상 메서드가 없어도 추상 클래스를 선언할 수는 있다.

추상 클래스의 메서드가 아무 동작도 하지 않기를 원할 때 사용한다. 메서드 선언은 있으되 몸체는 없는 형태로 구현하는 것이다.

추상 클래스는 인스턴스를 만들 수 없고, new를 사용할 수 없다. 그러므로 하위 클래스에게 메서드의 구현을 강제한다. 오버라이딩이 강제된다.

* 생성자

클래스의 인스턴스를 만들 때마다 new 키워드를 사용한다. 클래스명도 메서드이다. 반환값이 없고 클래스명과 같은 이름을 가진 메서드를 객체 생성자 메서드라고 한다. 이를 줄여서 생성자라고 한다. 인자가 없는 기본 생성자는 자바에서 자동으로 만들어 준다. 필요하다면 인자를 갖는 생성자를 더 만들수도 있다.

```java
public class Driver02 {
    public static void main(String[] args) {
        동물 뽀로로 = new 동물("뽀로로");
        동물 무명 = new 동물();
    }
}
// 무명 줄은 에러. 인자가 있는 생성자를 하나라도 만든다면 기본 생성자X
```

클래스 생성자는 존재하지 않는다. 다만 클래스가 스태틱 영역에 배치될 때 static 블록이 실행된다.

```java
public class 동물 {
    static {
        System.out.println("레디 온!");
    }
}
// 어딘가에서 new 동물();을 부르면 sysout 실행
```

static 블록에서는 static 멤버만 사용가능하다. 객체 멤버에는 접근할 방법이 없다. 객체 멤버는 클래스가 static 영역에 자리잡은 후에 객체 생성자를 통해 힙에 생성된다. 클래스의 static 블록이 실행되고 있을 때는 해당 클래스의 객체는 하나도 존재하지 않기 때문에, 객체 멤버에 접근할 수 없다.

동물 클래스의 인스턴스를 여러 개 만들어도 static 블록은 한 번만 실행된다.

p153 질문

* final

클래스, 변수, 메서드에 붙을 수 있다.

클래스

`public final class cat {}` 상속을 허락하지 않는다. 하위 클래스 X

변수

```java
final static int 정적상수1 = 1;
final static int 정적상수2;

final int 객체상수1 = 1;
final int 객체상수2;
```

159p 질문

메서드

`final void swim() {}` 재정의, 오버라이딩 금지

* instanceof

만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자이다.

`객체_참조\_변수 instanceof 클래스명` true/false를 반납한다.

이 연산자가 보이면 코드 점검이 필요하다. LSP를 어기는 코드

* package

클래스의 네임스페이스를 만들어주는 역할. 서로 다른 패키지 내에서는 클래스의 이름이 같아도 상관없이 완전 별개가 된다.

* interface, implements

인터페이스는 public 추상 메서드와 public 정적 상수만 가질 수 있다. 그래서 따로 메서드에 붙이지 않아도 자바가 알아서 붙여 준다. 그렇지만 명확하게 직접 붙여 주는 것도 좋을 것 같다.

자바 8부터는 디폴트 메서드라고 하는 객체 구상 메서드와 정적 추상 메서드를 지원할 수 있게 언어 스펙이 바뀌었다.

* this

객체가 자기 자신을 지칭할 때 쓰는 키워드.

지역 변수와 속성\(객체 변수, 정적 변수\)의 이름이 같은 경우 지역 변수가 우선

객체 변수와 이름이 같은 지역 변수가 있는 경우 this.로 객체 변수를 사용

정적 변수와 이름이 같은 지역 변수가 있는 경우 클래스명.으로 정적 변수를 사용

p169 질문

* super

바로 위 상위 클래스의 인스턴스를 지칭하는 키워드.

상위 클래스의 인스턴스 메서드를 호출할 수 있지만 상위의 상위 클래스는 X

