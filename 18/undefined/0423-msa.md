# 스프링부트를 활용한 마이크로서비스 개발

> 4월 4주차 기록  
> Ch 04 \(80p~90p\)

## 4. 마이크로서비스 시작하기

3장에서는 하나로 배포 가능한 애플리케이션을 완성했다!

> 처음부터 설계한대로 API서버, 배치서버, common 등을 멀티모듈로 구성해서 프로젝트를 해보니 일단 API서버 기능을 구현한 이후에 멀티모듈 구성을 하는 것이 더 좋아보임.

### 4-1. 작은 일체형 접근법

#### 4-1-1. 애자일 방식의 장점과 MSA 고찰

1. 소프트웨어를 고객에게 전달하기 위해 오랫동안 기다릴 필요 없음
2. 미리 완성된 시스템을 세밀히 설계하느라 몇 주를 보낼 필요 없음
3. 제품 or 프로젝트 기간 안에 동작하는 소프트웨어를 나눠서 전달할 수 있음

처음부터 MSA를 고집하면 안되는 몇가지 이유가 있다.

**\(1\) 애자일 방식 적용 어려움**

> 처음부터 MSA로 나눠서 개발하면 애자일 방식이 잘 안 된다고 한다.  
> 왜냐하면, MSA는 시스템을 배포, 관리, 테스트하기가 기술적으로 더 어렵기 때문.  
> 결론적으로 일체형보다 더 오래 걸린다.

**\(2\) 시스템 설계 문제**

> 시스템의 설계가 일체형보다 안좋아진다고 함.  
> 이유는, 여러 팀이 서로 다른 부분을 맡아서 개발하면 맡은 부분에만 관심을 둠  
> 초반에 한 설계는 쉽게 변경되기 때문에 MSA 전체를 관리해야하는 부담이 있음 End-To-End 테스트는 각자 만드는 코드를 테스트 하기 때문에 훨씬 어렵다!  
> API와 여러 MSA가 커뮤니케이션하는 방법을 명확히 알고 있지 않다면 일체형으로 시작하자.

#### 4-1-2. MSA를 잘 사용하려면..

MSA로 시작해 모든 것들을 동시에 잘 개발하려면 `개발, 통합 테스트, 표준 정하기, 명확한 API, 로깅과 모니터링, 에러 처리, 팀 간 커뮤니케이션 방법` 등 훨씬더 많은 주의가 필요하다.

이 중 하나만 실패해도 프로젝트가 위태로워진다.

따라서 처음은 바로 일체형 애플리케이션으로 시작하는 방법이 더 좋다.

여기서, 다음과 같이 계획한다면 나중에 일체형 애플리케이션을 MSA로 쉽게 나눌 수 있다.

* 도메인 컨텍스트를 따라 루트 패키지 코드 분리.
  * ex\) 고객 관련 기능\(개인, 회사, 주소 등\)과 주문 관련 기능\(주문 생성, 배송, 관리 등\)이 있다.
  * 루트 패키지에서 바로 계층을 나누는 것이 아니라 먼저 고객\(customer\)과 주문\(orders\)으로 나눈다.
  * 그리고 고객과 주문 각각 레이어로 패키지를 나누고, 패키지 기반의 클래스의 접근 수준을 제어한다.
  * 이런 구조를 만들면 도메인 컨텍스트에 따라 비즈니스 로직을 분리할 수 있고, 나중에 적은 리팩터링으로 MSA 분리가 가능하다.
* 의존성 주입의 이점 활용.
  * 인터페이스 기반으로 코드를 작성하면 스프링이 해당 구현체를 주입한다.
  * 이 패턴을 활용하면 리팩터링이 훨씬 쉬워진다.
  * ex\) 비즈니스 로직을 한 곳에 넣는 대신, 다른 MSA를 호출하도록 구현체를 바꿀 수 있다.
* 컨텍스트를 정의하고 나면 애플리케이션 전반에서 일관된 이름을 지을 수 있다.
  * 설계 단계에서 경계가 명확해질 때까지 도메인 로직을 옮기고\(작은 일체형에선 더 쉽다.\)
  * 그 이후에는 경계를 유지하면 된다.
  * 쉽게 개발하려고 비즈니스 로직을 엉키게 하지 말자!
* 일반적인 패턴을 찾자.
  * ex\) 나중에 공통 라이브러리로 뽑아낼 부분을 정의하자.
* 다른 사람들도 아키텍처를 이해하고 따를 수 있도록 peer review를 진행하자.
* PM과 향후 일체형을 분리할 시간을 정하자. 
  * 일체형을 분리하는 전략에 대해 설명하고, 리팩터링은 꼭 필요하고 아무 문제 없다는 것에 모두 공감하는 문화를 만들자.

#### 4-1-3. 작은 일체형 서비스의 장단점

최소 첫 릴리스 까지는 작은 일체형 서비스를 유지하는게 좋다고 한다.

장점을 살펴보자.

1. 비즈니스 사용자가 원하는 것을 확인하고 수정 사항을 적용하면서 시스템 개선  
2. 도메인 모델을 쉽게 바꿀 수 있다. 도메인 모델이 적절한지 충분히 확인하고 적용할 수 있다.  
3. 팀 또는 여러 팀이 공통 기술과 기능적인 회사 가이드라인에 익숙해진다.  
4. 도메인 간 공통 기능을 정의하고 라이브러리로 뽑아낼 수 있다.  
5. 팀원 모두과 완성된 시스템의 첫 번째 버전으로 함께 작업한다. 시스템 전체 내용을 같이 이해한다!

단점도 있다.

1. 스파게티 소스코드 작성 가능성 높아짐. 
   * 하지만 좋은 패턴을 따라 설계하면 나중에 충분히 분리 가능!
2. 첫 번째 배포 전략은 나중에 쓸모가 없어진다.
   * 하지만 배포 관련 도구를 활용해 같은 방식으로 서비스 여러개에 적용하면 재사용 가능!
3. 여러사람이 동시에 같은 코드를 가지고 작업하는 비효율
   * 그래서 되도록 작게 시작하는 것이 좋다.
   * PM과 협의해서 작은 일체형을 계획하면 첫 번째 릴리스에는 많은 인력이 필요하지 않을 수 있다.

#### 4-1-4. 일체형 분석하기

현재 애플리케이션의 구성은 다음과 같다.

![img](../../.gitbook/assets/4_application.png)

이렇게 만들어진 작은 일체형 서비스의 요구사항을 세 부분으로 나눠보자.

1. 곱셈을 생성하고 계산을 검증하는 곱셈 도메인.
2. 사용자 정보를 다루는 사용자 도메인.
3. REST API로 통신하고 웹 페이지를 보여주는 UI 컴포넌트.

이 세 부분은 **곱셈 도메인 개체**와 **사용자 도메인 개체**의 **참조를 재설계**하는 것처럼 독립적으로 시작하고 배포할 수 있다.

* UI는 도메인을 고려하지 않고 애플리케이션의 기술적인 컴포넌트를 분리하자.
* 애플리케이션의 기능을 REST API로 구축해서 웹 UI는 독립적으로 배포되는 컴포넌트가 됐다.
* 따라서 같은 API를 사용하는 모바일 앱을 만들 수 있다!
* 또한, UI를 여러 서비스\(예를 들면 곱셈과 사용자\)의 API를 소비하는 싱글 페이지 애플리케이션으로 개선할 수도 있다.
* 이런 이유로 UI 코드는 여러 소프트웨어 프로젝트에서 다른 서비스에 포함되는 경우가 많다.

### 4-2. 새로운 기능 추가

곱셈 애플리케이션은 두고, 새로운 기능을 가진 두 번째 스프링 부트 애플리케이션을 만들어보자.

> 사용자 스토리 3\(요구사항\)  
> 매일 문제를 풀기 위해 좀 더 동기부여가 되면 좋겠다! 쉽게 포기하지 않게!

다음 요구사항을 만족시키기 위한 여러가지 방법이 있지만, 아이디에이션을 거쳐 게임화\(gamification\)를 하기로 했다고 가정하자.

* 아키텍처를 고민해보면, 게임화는 곱셈을 푸는 것과 아무 상관이 없다!
* 새로운 모델을 정의하고 분리된 스프링부트 애플리케이션을 만들 수 있는 좋은 기회다!

> 1. 곱셈 마이크로 서비스  
> 2. 게임화 마이크로 서비스

#### 4-2-1. 게임화 기초

게임화가 뭔지 기본적인 개념과 기술을 알아보고, 어떻게 시스템에 적용할지 알아보자.

* 게임화는 게임에 사용되는 기법을 적용하는 설계 프로세스\(게임의 장점을 활용하기 위해 적용\)
* 플레이어를 동기부여하고, 프로세스나 App, 게임화 하려고 하는 무엇과도 상호작용하게 한다.

실습에서는 단순하게 게임 디자이너가 사용하는 몇 가지 도구만 다루겠다.

1. 점수
2. 배지
3. 리더보드

#### 4-2-2. 점수, 배지, 리더보드

* 잘하면 쌓이도록 점수를 도입
* 모두가 볼 수 있도록 점수를 공개하는 리더보드를 통해 경쟁심과 동기부여
* 특정 조건을 만족하면\(챌린지 등\) 배지를 지급

#### 4-2-3. 예제에 적용하기

* 정답을 제출하면 점수 10점 ++
* 순위를 보여준느 리더보드 페이지
* 배지 시스템\(정답 1, 10, 25, 50개\)

### 4-3. 마이크로서비스 아키텍처로 전환하기

시스템의 새로운 부분을 만들어보자.

* 독립적으로 배포가 가능
* 기존 비즈니스 로직과 분리

기존 스프링 부트 애플리케이션\(곱셈 마이크로서비스\)과 연결해야하고 독립적으로 확장 가능해야 한다.

> 계속 일체형 서비스를 확장해서 기능을 추가하면 안될까?

#### 4-3-1. 관심사를 분리하고 결합도 낮추기

기존 곱셈 로직에 게임화 로직을 추가하여 배포한다면 두 로직을 합치면서 에러가 발생할 위험이 있어, 관심사를 분리하는 이점이 사라진다.

> 프로젝트의 수명 주기에 따라 일체형이 더 커지는 것을 중지할 적당한 시점을 찾는게 중요하다.  
> 그렇지 않으면, 일체형이 계속 커지게 되고 에러를 잡기는 점점 힘들어진다.

* 결합도를 낮추는 일은 어렵다!
* 새로운 요구사항인 점수를 표로 보여주는 기능에서 많은 개발자는 조인 쿼리를 이용해 간단히 작성할것이다.
* 점점 복잡한 요구사항이 발생하여, 서비스+도메인+비즈니스로직이 섞이면 결합도가 높아진다.

> 곱셈 &lt;-&gt; 게임화 분리해서 마이크로서비스로 구현하면 결합도를 낮추는 방향으로 생각하게 된다.  
> 데이터를 부분적으로 복제하거나, 다른 서비스를 필요할 때 호출하는 방식 등등

#### 4-3-2. 독립적인 수정사항

곱셈과 게임화 도메인을 독립적으로 배포 가능한 서비스로 만들면 각자의 API를 이용해 따로 테스트가 가능하다!

* 게임화 팀은 곱셈 팀의 개발 주기에 상관없이 서비스를 개선할 수 있다.
* 통신을 위해 새로운 인터페이스가 필요하다면 가짜 호출이나 메시지를 만들어 각자 개발하면 됨!

#### 4-3-3.확장성

* 곱셈 게임이 대박나서 사용자가 수만명씩 접속하는 상황
* 클라우드 서버의 리소스가 부족하여 응답이 느려짐
* 시스템을 확장하고 로드 밸런싱 기술을 적용하고자 함

> 하나의 서비스로 관리하여 확장하는 경우보다 MSA로 관리한다면  
> 곱셈 서비스 확장을 더 많이하고, 게임화 서비스는 확장하지 않아도 되는 상황이다!

서버와 클라우드 컴퓨팅은 곧 비용이고, 절약하는 것은 모든 소프트웨어 프로젝트에서 중요한 일이니까!

### 4-4. 마이크로서비스 연결하기

분리해서 개발하는건 좋은데, 기존의 곱셈 문제를 풀고 점수를 얻는 로직으로 계속 확장해가도록 연결할 수 있을까?

일반적으로 생각하면 다음 세 가지 방법이 있다.

1. 두 개의 서비스가 DB를 공유해서 게임화 서비스가 데이터를 바로 사용
2. 게임화 서비스가 곱셈 서비스에서 주기적으로 데이터를 끌어와 점수와 배지를 준다.
   * 이렇게 하려면 기존 서비스에 REST API를 추가해야 합니다.
3. 곱셈 서비스에서 무슨 일이 있을 때마다\(답안을 받으면\) 게임화 서비스를 호출해 데이터를 전송하고 게임 통계를 업데이트.
   * 일종의 원격 프로시저 호출\(RPC\)방식

첫 번째는 좋은 방법이 아니다!

서비스들이 서로의 데이터에 접근하고 섞이면서 컨텍스트를 분리하는 이점이 대부분 사라진다.

두 번째는 좀 더 낫지만 새로운 데이터를 지속적으로 끌어와야 하고, 이미 처리된 답안을 추적해야 한다.

* ex\) 받은 답안이 게임화 처리가 됐는지 확인

세 번째는 데이터를 끌어오지 않아도 되기 때문에 두 번째보다 낫다. 하지만 더 개선할 점이 있다.

* 곱셈 서비스는 게임화 서비스를 알 필요가 없다!
* 곱셈 서비스를 게임화 서비스 없이 그 자체로 동작할 수 있도록 설계해야 한다.

세 번째 방식을 개선해서 서비스가 최대한 분리된 상태로 통신하도록 설계하자.

* 곱셈 서비스는 곱셈 답안을 받았다는 것을 자기에게 관심을 가진 서비스에게 알려준다.
  * 메시지 버스에 이벤트를 전송하면 가능!
  * 다른 비즈니스 프로세스에 주는 영향 없이 투명하게 연결 가능

#### 여러가지 상황

1. 정답을 연속으로 너무 많이 보내는 것처럼 의심스러운 동작을 보이면 관리자에게 메일을 보내보자.
2. 사용자별 또는 시간별 정답의 분석 결과와 통계 정보를 수집
3. 문제를 맞추고 포스팅할 수 있도록 소셜 네트워크 플러그인 추가

반응형\(reactive\) 패턴을 이용해 설계하면 유연성이 높아지고 이런식으로 설계하는 것이 **이벤트 중심 아키텍처** 또는 **반응형 시스템**이다.

* 1번과 2번은 이벤트 중심 전략
* 3번은 요청-응답 패턴이 더 적합하다.

### 4-5. 이벤트 중심 아키텍처

* 중요한 행위가 일어날 때마다 여러 마이크로서비스가 이벤트를 전송
* 각 마이크로서비스는 메시지 브로커\(=이벤트 버스\)를 통해 이벤트를 주고 받음
* 마이크로서비스는 각자 관심 있는 이벤트를 구독하고 이벤트를 처리

> 중요한 건 이벤트는 이미 일어난 사건이라는 점  
> 보통 과거형으로 이름을 짓는다.\(ex-MultiplicationSolvedEvent\)

해당 이벤트를 구독한 마이크로서비스는 **각자의 비즈니스 로직**을 수행하고 다른 이벤트를 발행\(pubilsh\)할 수도 있다!

이런 작용-반작용 패턴을 기반으로하는 시스템을 반응형 시스템이라고 함

#### 4-5-1. 관련 기법

이벤트 중심 아키텍처는 이벤트 소싱\(Event sourcing\), 도메인 주도 설계\(DDD\), CQRS 같은 기법과 밀접한 연관이 있다.

> 위 기법들은 독립적으로 적용할 수 있으며 항상 합리적으로 사용해야한다!  
> 문제를 해결하는 도구로써 사용하라는 의미이다.

**✅ 이벤트 소싱**

비즈니스 개체를 저장하는 방식

* 시간이 지나면서 변하는 정적 상태로 모델링하는 대신, 변경할 수 없는 일련의 이벤트로 모델링하는 것
* 이벤트 시퀀스를 \(트랙잭션 단위\) 모아두는 방식으로 은행 애플리케이션이 대표적이다.

> 이벤트 소싱은 이벤트 중심의 시스템에서 더 쉽게 구현할 수 있지만, 많은 이벤트를 전체적으로 적용하려면 모델링해야하는 이벤트 수가 크게 증가한다. 따라서 이번 예제에서는 이벤트 소싱을 사용하지는 않음

**✅ 도메인 주도 설계**

비즈니스 도메인이 시스템의 핵심이라는 소프트웨어 설계 철학이자 소프트웨어 패턴

* 시스템을 별도로 처리할 수 있도록 하위 도메인 같은 바운디드 컨텍스트\(bounded context\)를 정의할 수 있다.
* 이는 마이크로서비스를 설계할 때 유용

> 마이크로서비스는 바운디드 컨텍스트에 쉽게 매핑하고 DDD 접근 방식의 장점을 활용할 수 있다!

예제는 DDD 원칙을 따라 개발한다.

**✅ CQRS\(Command-Query Responsibility Segregation**

`명령-쿼리 책임 분리`를 의미하며 데이터를 조회하는 모든 쿼리 모델과 데이터를 업데이트하는 커맨드 모델을 분리하는 패턴

* 복잡한 시스템을 사용하는 대신 데이터를 매우 빠르게 읽어올 수 있다는 장점!
* 저장 모델을 이벤트 저장 모델로 하면 이벤트 소싱과 함께 사용할 수 있다.

