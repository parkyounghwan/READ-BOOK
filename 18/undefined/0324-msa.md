# 스프링부트를 활용한 마이크로서비스 개발

> 3월 4주차 기록  
> Ch 03 \(44p~56p\)

## 3. 3계층 스프링 부트 애플리케이션

첫 번째 REST API를 완성하였고, 이제 기본적인 UI를 만들어본다.

### 3-4. 프런트엔드\(웹 클라이언트\)

사용자가 REST API를 직접 호출할 수 없으니, 사용자 친화적인 인터페이스를 만든다.

간단하게 작성하기 위해 HTML과 jQuery로 REST 웹 서비스와 통신하도록 한다.

Spring Boot는 내장 Tomcat 서버로 정적 콘텐츠를 제공하게 되어서 편하게 웹 서비스를 테스트할 수 있다.

웹 페이지 기능은 다음과 같이 정의한다.

* 페이지가 로드된 후에 REST API로 무작위 곱셈 문제를 가져와 보여준다.
* 폼 제출\(submit\) 이벤트 리스너를 등록하고, 폼 제출의 기본 동작 대신 폼에서 데이터를 가져와 채점 결과를 확인하는 API를 호출하고 결과를 사용자에게 보여준다.

정적 페이지를 로드할 `main/resources/static` 폴더에 `html` 인 `index.html` 파일과 `styles.css`, `multiplication-client.js`를 작성하여 jQuery로 간단한 동작을 실행한다.

`index.html`

```markup
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Multiplication v1</title>
  <link rel="stylesheet" type="text/css" href="styles.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="multiplication-client.js"></script>
</head>

<body>
<div>
  <h1>안녕하세요, 소셜 곱셈입니다!</h1>
  <h2>오늘의 문제:</h2>
  <h1>
    <span class="multiplication-a"></span> x <span class="multiplication-b"></span> =
  </h1>
  <p>
  <form id="attempt-form">
    답은? <input type="text" name="result-attempt"><br>
    닉네임: <input type="text" name="user-alias"><br>
    <input type="submit" value="확인">
  </form>
  </p>
  <h2><span class="result-message"></span></h2>
</div>
</body>
</html>
```

`styles.css`

```css
html, body {
  height: 100%;
}

html {
  display: table;
  margin: auto;
}

body {
  display: table-cell;
  vertical-align: middle;
}
```

`multiplication-client.js`

```javascript
function updateMultiplication() {
  $.ajax({
    url: "http://localhost:8080/multiplications/random"
  }).then(function (data) {
    // 폼 비우기
    $("#attempt-form").find("input[name='result-attempt']").val("");
    $("#attempt-form").find("input[name='user-alias']").val("");
    // 무작위 문제를 API로 가져와서 추가하기
    $('.multiplication-a').empty().append(data.factorA);
    $('.multiplication-b').empty().append(data.factorB);
  });
}

$(document).ready(function () {

  updateMultiplication();

  $("#attempt-form").submit(function (event) {

    // 폼 기본 제출 막기
    event.preventDefault();

    // 페이지에서 값 가져오기
    var a = $('.multiplication-a').text();
    var b = $('.multiplication-b').text();
    var $form = $(this),
      attempt = $form.find("input[name='result-attempt']").val(),
      userAlias = $form.find("input[name='user-alias']").val();

    // API 에 맞게 데이터를 조합하기
    var data = {user: {alias: userAlias}, multiplication: {factorA: a, factorB: b}, resultAttempt: attempt};

    // POST를 이용해서 데이터 보내기
    $.ajax({
      url: '/results',
      type: 'POST',
      data: JSON.stringify(data),
      contentType: "application/json; charset=utf-8",
      dataType: "json",
      success: function (result) {
        if (result.correct) {
          $('.result-message').empty().append("정답입니다! 축하드려요!");
        } else {
          $('.result-message').empty().append("오답입니다! 그래도 포기하지 마세요!");
        }
      }
    });

    updateMultiplication();
  });
});
```

우리가 만든 REST API를 인터페이스 기반으로 간단하게 테스트할 수 있도록 작성한 코드이다.

#### 3-4-1. 애플리케이션 사용해보기

`mvnw spring-boot:run` 명령어를 통해 애플리케이션을 실행할 수 있고, IDE의 `RUN`을 통해서도 실행할 수 있다.

또 JAR 파일을 패키징해서 고객에게 전달할 수도 있다!

localhost:8080/index.html에 접속하면 계산 페이지를 확인할 수 있고 문제를 암산해서 풀어볼 수 있다.

### 3-5. 새로운 요구사항\(데이터 저장\)

지금까지 서비스를 설계하고 구현하였고, 애플리케이션을 사용해보니 다음과 같은 요구사항이 생겼다고 가정하자.

> 사용자 스토리 2  
> 최근에 제출한 답안을 보고싶다. 제출한 답안을 보면서 내가 얼마나 잘하고 있는지 못하고 있는지 알 수 있을 것 같다.

요구사항을 만족하기 위해 다음과 같이 설계해야 한다.

* MultiplicationResultAttempt 클래스의 인스턴스를 모두 저장한다. \(이후에 추출해서 사용하기 위해\)
* 특정 사용자의 최근 답안을 가져오는 새로운 REST 엔트포인트를 만든다.
* 답안을 검색하는 새로운 서비스\(비즈니스 로직\)를 만든다.
* 사용자가 답안을 제출하면 답안 내역을 보여주는 웹 페이지를 만든다.

> 이 때 사용자 스토리를 잘 생각해보면, 지금은 사용자가 제출한 답안을 바로 채점하기 때문에 MultiplicationResultAttempt 클래스가 채점 결과를 나타내는 플래그를 따로 가지고 있지 않다. 기존 요구사항에 대처하기 충분했지만 새로 발생한 요구사항을 만족하려면 결과를 추출하기 위해 매번 다시 계산을 해야하는 문제가 발생한다.  
> `코드 리팩터링`을 통해 다음 문제를 해결해보자.

#### 3-5-1. 애자일과 리팩터링

애자일 방법론에 따라 일하려면 리팩터링을 잘해야한다.

* 고객에게 가치를 최대한 빨리 전달하기를 원함
* 그 과정에서 애플리케이션이 계속 발전함
* 따라서 초기 단계에 애프리케이션 설계에 너무 많은 시간을 투자하는 것은 잘못됐다는 것을 의미
* 왜냐하면 요구사항은 계속 변할 수 있으니까

여기서 균형을 잘 잡고 비전과 MVP\(최소 기능 제품\)를 정의하는 것이 핵심!

> 비즈니스적인 관점에서 프로젝트 종료 시점에 무엇을 이루고자 하는지 명확한 비전 갖기  
> 유스케이스를 잘 정의한 MVP  
> 스프린트를 기반으로 작업 이 때 방향과 작업 내용을 명확히 하면 좋음

그래서 비즈니스 이해관계자들\(PM, PO, 개발자 등\)이 애자일 과정에서 설계와 아키텍처가 변경될 수 밖에 없다는 것을 인지하고 `리팩터링`이 무엇인지, 왜 필요한지 이해하고 받아들이는 것이 중요하다!

이 예제 코드를 작성할 때도 사전에 데이터 저장 요구사항을 고려할 수 있었지만, 애자일과 리팩터링을 설명하기 위해 추가 요구사항으로 작성했다고 한다.

#### 3-5-2. 리팩터링

왜 리팩터링이 필요한지 이해했고, 리팩터링 작업을 정리해보자.

1. 사용자가 제출한 답안\(`MultiplicationResultAttempt`\)에 정답인지 아닌지 나타내는 boolean 값을 추가해야한다. 클래스에 값을 담았다가 나중에 데이터베이스에 저장한다.
2. 서비스\(`MultiplicationServiceLmpl`\)에서는 해당 결과를 바로 반환하는 대신 답안 내에 저장해야 한다.
3. 클라이언트가 답안을 채점하면 안 됨. 따라서 해당 필드는 REST API에서 읽는 대신 내부적으로 계산한다.
4. 새로운 환경을 반영하기 위해 테스트를 수정한다.

```java
// import & @애너테이션 생략
public final class MultiplicationResultAttempt {

  private final User user;
  private final Multiplication multiplication;
  private final int resultAttempt;

  private final boolean correct;

  // JSON (역)직렬화를 위한 빈 생성자
  MultiplicationResultAttempt() {
    user = null;
    multiplication = null;
    resultAttempt = -1;
    correct = false;
  }
}
```

결과를 저장하기위해 클래스에 새로운 필드를 추가했다.

> Lombok에서 getter, setter, equals\(\), hashCode\(\), toString\(\) 메서드도 자동으로 업데이트 해주니 편하다!

이제 TDD의 새로운 생성자 적용해서 추가해주자.

`MultiplicationServiceImplTest.java`

```java
@Test
  public void checkCorrectAttemptTest() {
    // given
    Multiplication multiplication = new Multiplication(50, 60);
    User user = new User("john_doe");
    MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(
            user, multiplication, 3000, false);
    MultiplicationResultAttempt verifiedAttempt = new MultiplicationResultAttempt(
            user, multiplication, 3000, true);
    given(userRepository.findByAlias("john_doe")).willReturn(Optional.empty());

    // when
    boolean attemptResult = multiplicationServiceImpl.checkAttempt(attempt);

    // then
    assertThat(attemptResult).isTrue();
    verify(attemptRepository).save(verifiedAttempt);
  }

  @Test
  public void checkWrongAttemptTest() {
    // given
    Multiplication multiplication = new Multiplication(50, 60);
    User user = new User("john_doe");
    MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(
            user, multiplication, 3010, false);
    given(userRepository.findByAlias("john_doe")).willReturn(Optional.empty());

    // when
    boolean attemptResult = multiplicationServiceImpl.checkAttempt(attempt);

    // then
    assertThat(attemptResult).isFalse();
    verify(attemptRepository).save(attempt);
  }
```

두 메서드를 호출해서 correct 필드에 값을 넣을 수 있도록 서비스 구현체 안에 새로운 로직을 추가해보자.

`MultiplicationServiceImpl.java`

```java
  @Transactional
  @Override
  public boolean checkAttempt(final MultiplicationResultAttempt attempt) {
    // 해당 닉네임의 사용자가 존재하는지 확인
    Optional<User> user = userRepository.findByAlias(attempt.getUser().getAlias());

    // 조작된 답안을 방지
    Assert.isTrue(!attempt.isCorrect(), "채점한 상태로 보낼 수 없습니다!!");

    // 답안을 채점
    boolean isCorrect = attempt.getResultAttempt() ==
            attempt.getMultiplication().getFactorA() *
                    attempt.getMultiplication().getFactorB();

    MultiplicationResultAttempt checkedAttempt = new MultiplicationResultAttempt(
            user.orElse(attempt.getUser()),
            attempt.getMultiplication(),
            attempt.getResultAttempt(),
            isCorrect
    );

    // 답안을 저장
    attemptRepository.save(checkedAttempt);

    return isCorrect;
  }
```

만약 메서드 인자인 `attempt`에 correct 필드 true를 담아서 전송하는 공격\(?\)에 대비해 제대로 채점한 결과를 새로운 인스턴스인 `checkedAttempt`에 저장하여 **불변성**을 유지하기 위해 새로운 복사본을 생성한다.

스프링에 포함된 Assert 클래스로 불량 사용자가 있을 때 예외를 발생시킬 수 있다.

이제 Test 코드도 수정하면 다음과 같다.

`MulitiplicationResultAttemptControllerTest.java`

```java
  void genericParameterizedTest(final boolean correct) throws Exception {
    // given (지금 서비스를 테스트하는 것이 아님)
    given(multiplicationService
            .checkAttempt(any(MultiplicationResultAttempt.class)))
            .willReturn(correct);
    User user = new User("john");
    Multiplication multiplication = new Multiplication(50, 70);
    MultiplicationResultAttempt attempt = new MultiplicationResultAttempt(
            user, multiplication, 3500, correct);

    // when
    MockHttpServletResponse response = mvc.perform(
            post("/results").contentType(MediaType.APPLICATION_JSON)
                    .content(jsonResultAttempt.write(attempt).getJson()))
            .andReturn().getResponse();

    // then
    assertThat(response.getStatus()).isEqualTo(HttpStatus.OK.value());
    assertThat(response.getContentAsString()).isEqualTo(
            jsonResultAttempt.write(
                    new MultiplicationResultAttempt(attempt.getUser(),
                            attempt.getMultiplication(),
                            attempt.getResultAttempt(),
                            correct)
            ).getJson());
  }
```

보통 REST API에서 응답을 변경하려면 프런트엔드도 함께 수정해야하는데, 이 경우에는 수정 전에도 Response 자체가 JSON 객체로 Boolean 값 만을 포함하였는데 지금은 JSON 객체에 MultiplicationResultAttempt를 포함하고 결과인 Boolean 값도 포함한 객체이기 때문에 여전히 `javascript`코드도 잘 동작한다.

