# 1부\_소개

프로그램을 구현하는 것과, 제대로 만드는 건 다르다 \(적정 수준과 지식이 필요하다\) 기술을 향한 열정, 전문가가 되려는 열망

## 1장 설계와 아키텍처란?

아키텍처

1. 저 수준을 아우르는 고 수준의 무언가를 가리킬 때 사용
2. as like 집의 형태, 외관, 입면도, 공간이나 방의 배치

설계

1. 저수준의 구조 또는 결정 사항을 의미
2. as like 콘센트, 전등 스위치, 전등 위치

저수준의 세부사항, 고수준의 구조는 모두 필요 요소이다

고 수준에서 저 수준으로 향하는 의사 결정의 연속성은 존재한다.

### 목표는?

```java
소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
```

새로운 기능을 출시할 때마다 비용이 증가한다면 나쁜 설계이다.

### 사례 연구

직원 수의 증가 추이는 지수함수인데, 회사의 생산성은 로그함수라면?

거기에 코드 라인당 비용은 또 지수함수라면?

→ 회사 성장을 저해할 것이며 엉망진장이 되어가고 있는 신호이다.

#### 엉망진장이 되어가는 신호, 경영자의 시각

급하게 만들거나, 결과물의 총량을 프로그래머 수만으로 생각하거나, 코드와 설계의 구조를 깔끔하게 만드려는 생각을 전혀 하지 않으면 파국으로 치닫는 비용 곡선에 올라타게 된다.

기능 개발을 하기 보다는 엉망진창인 코드를 수정하는 데 더 많은 시간을 소모하는 개발자

경영자가 보기에도 월 인건비가 출시마다 지수함수로 되는 모습을 보면 기암을 칠 것이다.

#### 무엇이 잘못되었나?

현대의 대다수 개발자는 뼈빠지게 일한다.

하지만 뇌는 자고 있다.

하지만 `훌륭하고 깔끔하게 잘 설계된 코드가 중요하다`는 사실을 알고 있는 바로 그 뇌가 잠자고 있다.

우리가 조심해야 하는 악마의 거짓말

1. 코드는 나중에 정리하면 돼. 당장은 시장에 출시하는 게 먼저야

   뒤에 경쟁자들이 득실거리고, 앞서 가려면 가능한 빠르게 달려야 하기 때문에 반은 맞는말

   그래서 이전의 코드로 되돌아가 작업할 시간도 없이 새로운 기능에 시달린다

   시간에 쫒기면서, 개발자는 개발자도 생산성을 유지할 수 있다고 자신의 능력을 과신한다

2. 지저분한 코드를 작성하면 단기간엔 빠르게 갈 수 있고, 장기적으로 볼때만 생산성이 낮아진다

엉망인 코드를 만들다가, 나중에 기회가 되면 엉망이 된 코드를 정리하는 태세로 전환할 수 있다고 과신함

제이슨 고먼의 실험

주제 : 정수를 로마 숫자로 변환하는 단순한 프로그램을 완성하기

완성의 기준 : 사전에 정의한 일련의 인수 테스트를 통과하면 개발이 완료된 것으로 봄

GIVEN : TDD 를 1 ~ 3일 째 적용, 나머지 3일은 TDD 적용하지 않고 코드 작성

THEN

1. TDD 적용한 날이 지날수록 이전 날보다 빠르게 프로그램 완성
2. TDD 를 적용한 날이 적용하지 않은 날보다 10% 빠르게 작업이 완성됨
3. TDD 적용하지 않은 날 중 가장 빠른 날보다, TDD 적용하고 가장 느린 날이 더 빠름

실제로도 그렇다. 테스트 코드가 있음으로 프로그래머는 안정감을 갖고 에러 발생 시 어디에 문제가 있는지 모니터링도 가능하다.

### 결론

조직에 스며든 과신을 인지하여 방지하고, 아키텍처의 품질을 심각하게 고민해보는 시간을 갖자

좋은 소프트웨어 아키텍처가 무엇인지를 알고, 그 속성도 이해해야 한다

## 2장 두 가지 가치에 대한 이야기

`행위`와 `구조`

SW 개발자는 두 가치를 모두 높게 유지해야 하는 책임을 진다

하지만 두 개 중 하나 그것도 덜 중요한 가치에 집중하여 SW 시스템이 쓸모없게 되어버린다.

### 행위

프로그래머를 고용하는 이유

이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서

이를 위해 프로그래머가 하는 일

기능 명세서나 요구사항 문서를 구체화 할 수 있도록 도움

이해 관계자의 기계가 이러한 요구사항을 만족하도록 코드를 작성

기계가 이러한 요구사항을 위반할 시 디버거를 열고 코드를 고침

이런 기계에 구현하고 버그를 수정하는 일이 자신의 전체 업무라고 믿는다면 그건 오산

### 아키텍처

SW = 부드러운\(soft\) 제품\(ware\)

부드러움의 의미

1. SW를 만든 이유는 `기계의 행위를 쉽게 변경`하도록 하기 위해서다.
2. `변경하기 쉬운 프로그램`을 우리는 만들어야 한다.
3. `변경사항`을 `간단하고 쉽게 적용`할 수 있어야 한다.
4. 변경사항을 적용하는 데 드는 어려움은 `변경하는 범위`에 **비례**해야 하며, 

   `변경사항의 형태`와는 **관련이 없어야** 한다.

SW 개발 비용의 증가를 결정짓는 주된 요인 : 변경사항의 `범위`와 `형태`의 차이

이해관계자와 개발자 사이의 괴리

1. 이해관계자는 범위가 비슷한 일련의 변경사항을 제시할 뿐
2. 개발자 입장에서는 복잡도가 지속적으로 증가하는 퍼즐판위에서 

   이해관계자가 계속해서 퍼즐 조각을 맞추라는 지시를 하는 것처럼 느껴짐

3. 시스템의 형태와 요구사항의 형태가 서로 맞지 않기 때문에

   새로운 요청 사항이 생길 때마다 바로 이전의 변경사항을 적용하는 것보다 더 힘들어짐

위의 문제는 모두 아키텍처에서 기인

아키텍처가 특정 형태를 다른 형태보다 선호하면 할 수록 새로운 기능을 이 구조에 맞추는 게 힘들어진다.

그래서 아키텍처는 독립적이어야 한다.

### 더 높은 가치

개발자의 흔한 2지선다 고민

1. 기능 vs 아키텍처 둘 중에 어느 가치가 더 높은가?
2. SW 시스템이 동작하도록 만드는 것 vs SW 시스템을 더 쉽게 변경할 수 있도록 하는 것

전자도 중요하긴 하지만, 후자를 배척하면 안된다.

완벽하게 동작하지만 수정이 불가능한 프로그램 : 거의 쓸모가 없다

동작은 하지 않지만 변경이 쉬운 프로그램 : 앞으로도 유용하게 쓰일 수 있다

불가능이랑 존재하지 않는다, 다만 아래 내용으로 치환될 수 있다,

수정이 불가능하다는 것

1. 수정이 현실적으로 불가능하다는 것
2. 변경에 드는 비용이, 변경으로 창출되는 수익을 초과함
3. 변경에 드는 시간이 기능 개발보다 오래 걸림

`변경 비용이 너무 커서 현실적으로 적용할 수 없다` : 기획자 및 경영진은 노발내발할 것이 당연하다 😇

### 아이젠하워 매트릭스

드와이트 D 아이젠하워 이야기

중요 O `|` 긴급 O : 존재 X

중요 O `|` 긴급 X : 존재 O

중요 X `|` 긴급 O : 존재 O

중요 X `|` 긴급 X : 존재 X

SW 입장으로 이야기해볼까?

* `행위`는 긴급하지만, 매번 높은 중요도를 가지지 않는다 = 긴급
* `아키텍처`는 중요하지만, 즉각적인 긴급성을 가지지 않는다. = 중요

물론 중요O 긴급O, 중요X 긴급X 인 일도 존재한다. 그 경우 우선순위를 매긴다면

1. 중요 O `|` 긴급 O
2. 중요 O `|` 긴급 X 
3. 중요 X `|` 긴급 O
4. 중요 X `|` 긴급 X

결과 → 행위 : 1, 3번째 \| 중요 : 1, 2번째

우리의 주 실수는 3번째를 1번째로 놓는다. \(그러면서 개판인 코드를 작성하면서 정당방위를 부여한다\)

1. 업무 관리자는 `중요` 내용을 고려하기엔 한계가 있기 때문에 개발자는 딜레마에 빠진다.
2. 그걸 고려하면서 긴급한 내용을 다루고, 

   때로는 그로 인한 협상을 진행하기 위해 프로그래머는 존재한다.

아키텍처의 중요성을 설득하는 일은 SW 개발팀에서 마땅히 책임져야 한다.

### 아키텍처를 위해 투쟁하라

싸움판에 뛰어들고 투쟁해야 한다. \(각자 팀마다 자신만의 가치를 위해 투쟁한다\)

효율적인 SW 개발팀은 이러한 투쟁에 정면으로 맞선다.

SW 개발자인 너 자신도 이해관계자임을 명심해라

SW 아키텍트

* 시스템이 제공하는 특성이나 기능보다는 시스템의 구조에 더 중점을 둠
* 이러한 특성과 기능을 `개발하기 쉽고 간편하게 수정`할 수 있으며 `확장하기 쉬운` 아키텍처를 만들어야 한다.

아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 든다

일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다

\( = SW 개발팀이 스스로 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 뜻\)

