# 2부\_벽돌부터 시작하기: 프로그래밍 패러다임

SW 아키텍처는 코드로 시작

컴퓨터 프로그래밍이라고 부르는 분야의 토대를 쌓은 앨런 튜링

* 반복문, 분기문, 할당문, 서브루틴, 스택 등의 구조 존재

1940년대 등장한 어셈블러

* 바이너리 코드에서 해방됨

최초 컴파일러 A0 개발 \(그레이스 호퍼\)

새로운 프로그래밍 언어 홍수처럼 나옴

프로그래밍 패러다임에도 혁신적인 변화가 옴

* 프로그래밍을 하는 방법
* 언어에는 독립적
* 어떤 프로그래밍 구조를 사용할지, 언제 이 구조를 사용해야 하는지를 결정

패러다임엔 3가지가 존재함

1. 구조적 프로그래밍
2. 객체지향 프로그래밍
3. 함수형 프로그래밍

## 3장 패러다임 개요

### 구조적 프로그래밍

최초로 적용된 패러다임

데이크스트라는 무분별한 점프\(goto\) 는 프로그램 구조에 해롭다는 사실을 제시함

`if / then / else`, `do / while / until` 와 같은 익숙한 구조로 대체시킴

```java
구조적 프로그래밍은 제어 흐름의 직접적인 전환에 대해 규칙을 부과한다.
```

### 객체 지향 프로그래밍

올레 요한 달, 크리스텐 니가드에 의해 등장

함수 호출 스택 프레임을 힙으로 옮기면 함수 호출이 반환된 이후에도 `함수`에서 선언된 `지역 변수`가 오래 유지할 수 있음을 발견함

여기서

`함수` : 클래스의 생성자 / `지역 변수` : 인스턴스 변수 / `중첩 함수` : 메서드

```java
객체지향 프로그래밍은 제어 흐름의 간접적인 전환에 대해 규칙을 부과한다.
```

### 함수형 프로그래밍

컴퓨터 프로그래밍 자체보다 일찍 나온 개념

람다 계산법

LISP 언어의 근간이 되는 개념

람다 계산법의 기초가 되는 개념

* 불변성
* 심볼 값이 전혀 바뀌지 않는다는 개념

```java
함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
```

### 생각할 거리

각 패러다임은 프로그래머에게서 권한을 부여하지 않고, 권한을 박탈한다.

각 패러다임은 무엇을 하면 안되는지를 말한다. \(규칙을 가장한 제한을 부과한다\)

각 패러다임은 각각의 권한을 앗아간다 \(goto문, 함수 포인터, 할당문\)

앞으로 패러다임은 이렇게 3개가 전부일 것이다.

수십년이 지났지만 새로 만들어진 패러다임은 없다.

### 결론

우리는 아키텍처 경계를 넘나들기 위한 매커니즘으로 다형성을 이용한다.

ex. 함수형 프로그래밍을 통해 `데이터의 위치`, `접근 방법`에 대해 규칙을 부과한다.

ex. 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용한다

함수, 컴포넌트 분리, 데이터 관리

## 4장 구조적 프로그래밍

1950년대 당시 프로그래머라는 직업은 없었다. \(이론 물리학자에 만족\)

### 증명

문제 인식

* 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다
* 인간의 두뇌로는 한계가 있다 \(너무 많은 세부사항 존재\)

문제 해결 과정

1. 수학적인 원리를 통해 위 내용을 해결하고자 함

   공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층 구조를 만드는 것

   ```text
    유클리드 계층 구조

    공리 : 증명없이 참으로 받아들이는 명제 
               (ex. 두 점이 주어졌을 때 두 점을 지나는 직선이 단 하나 존재한다)

    정리 : 증명이라는 과정을 통해 참이라는 것이 밝혀진 명제

    보조 정리 : 정리를 증명하는 데 필요한 정리들

    따름 정리 : 보조 정리를 통해 자연스럽게 도출되는 정리
   ```

   ```java
    프로그래머는 입증된 구조를 이용하고, 
    이들 구조를 코드와 결합시키며, 
    그래서 코드가 올바르다는 사실을 스스로 증명하게 되는 방식
   ```

   → `단순한 알고리즘`에 대해 `기본적인 증명을 작성`할 수 있는 기법을 보여주기 위해 연구하기 시작

2. goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에서 방해가 됨을 발견

   합리적인 증명을 위해 반드시 필요한 `분할 정복 접근법`\(divide & conquer\)을 사용할 수 없음

3. 방해가 되지 않는 경우도 존재함을 발견

   이런 구조는 if/then/else, do/while 과 같은 분기 또는 반복문에 해당한다는 사실을 발견함

   모듈이 이러한 구조만을 활용한다면, 증명 단위로까지 모듈을 재귀적으로 세분화하는 것이 가능해 보임

4. 이러한 구조는 순차 실행과 결합했을 때 특별하다는 사실을 발견

   다른 사람 2명이 모든 프로그램은 `순차`, `분기`, `반복`이라는 3가지 구조로 표현할 수 있다는 사실을 증명함

5. 모듈을 증명가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이 증명됨

→ 구조적 프로그래밍이 탄생함

2라운드

1. 순차 구문

   순차 구문의 입력을 순차 구문의 출력까지 추적함 \(일반적인 수학과 같음\)

2. 분기 구문

   열거법을 재적용하는 방식으로 처리

   분기를 통한 각 경로를 열거한 후, 결과적으로 두 경로가 수학적으로 같은 결과를 만들어냄을 보임

3. 반복 구문

   귀납법을 사용함

   N의 경우가 올바를 때, N + 1 의 경우도 올바름 → 열거법 활용

   반복의 시작, 종료 조건 또한 열거법을 활용함

### 해로운 성명서

goto 문의 해로움을 발표하고 goto 문 신봉자들과 10년가까이 다툼

결국 goto 문은 사라짐

이로 인해 프로그래머는 제어 흐름을 제약 없이 직접 전환할 수 있는 권한이 없어짐

존재하더라도 범위를 제약시킴

### 기능적 분해

모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 됨

\(= `모듈을 기능적으로 분해할 수 있음`을 뜻함\)

거대한 문제 기술서 → 고수준의 기능들 → 저수준의 함수들 → 순차, 분기, 반복 구문으로 표현 가능

### 엄밀한 증명은 없었다

프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않음

현재 엄밀한 증명이 고품질의 소프트웨어를 생산하기 위한 적절한 방법이라고 믿는 프로그래머는 거의 없음

과학적 방법으로 간접 증명을 진행함

### 과학이 구출하다

과학 이론과 법칙은 그 올바름을 절대 증명할 수 없다 \(수학과는 다름\)

다른 실험을 통해 과학 이론이 뒤집어질 가능성은 열려 있음

과학은 서술된 내용이 틀렸음을 증명하는 방식으로 동작함 \(거짓을 증명하는 원리\)

참을 증명하는 원리인 수학과는 다름

### 테스트

테스트는 버그가 있음을 보여줄 뿐, 버그가 없다는 걸 보여줄 수는 없다. \(인정합니다\)

소프트웨어는 수학적인 시도가 아니라는 걸 깨달을 수 있다.

최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문

부정확함에 대한 증명은 입증 가능한 프로그램에만 적용이 가능하다

ex. 제약 없는 goto 문을 사용하는 등의 이유로 입증이 불가능한 프로그램 = 테스트를 많이 수행하더라도 올바르다고 볼 수 없음

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해하고, 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려 시도함

거짓임을 증명하는 테스트가 실패 시, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 됨

### 결론

구조적 프로그래밍이 가지는 가치 \(`반증 가능한 단위를 만들어 낼 수 있는 능력`\) 로 인한 정책

1. goto 문장은 지원하지 않음
2. 아키텍처 관점에서 기능적 분해를 최고의 실천법 중 하나로 여김

SW 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 \(테스트 쉽도록\) 만들기 위해 노력해야 한다.

