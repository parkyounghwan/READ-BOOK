# 0425

## 19.6 객체 생성 방식과 프로토타입의 결정

* 모든 객체는 추상 연산 `OrdinaryObjectCreate` 에 의해 생성된다
* 추상 연산 `OrdinaryObjectCreate` 는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달 받는다. 빈 객체를 생성한 후, 객체에 추가할 프로퍼티 목록이 인수로 전달되면 프로퍼티를 객체에 추가하고 인수로 전달받은 프로토타입을 객체의 \[\[Prototype\]\] 내부 슬롯에 할당한다.

### 객체 리터럴에 의해 생성된 객체의 프로토타입

* 자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때 프로토타입으로 `Object.prototype` 을 전달하며 추상 연산 `OrdinaryObjectCreate` 를 호출한다.

### Object 생성자 함수에 의해 생성된 객체의 프로토타입

* Object 생성자 함수를 인수 없이 호출하면 빈 객체가 생성된다.
* Object 생성자 함수를 호출하면 `OrdinaryObjectCreate` 를 호출되며 이때 전달되는 프로토타입은 `Object.prototype` 이다.

### 생성자 함수에 의해 생성된 객체의 프로토타입

* `new` 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 생성자 함수의 prototype 프로퍼티에 바인딩된 객체가 프로토타입으로 전달하며 `OrdinaryObjectCreate` 가 호출된다.

## 19.7 프로토타입 체인

* 프로토타입의 프로토타입은 언제나 `Object.prototype` 이다.
* **프로토타입 체인** : 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 **없다면** **\[\[Prototype\]\] 내부 슬롯의 참조**를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.
* 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘
* 모든 객체는 `Object.prototype` 을 상속받으므로 **프로토타입 체인의 종점**이다.
* `Object.prototype` 의 프로토타입은 `null` 이다.

```jsx
프로토타입 체인 : 상속과 프로퍼티 검색을 위한 메커니즘
스코프 체인 : 식별자 검색을 위한 메커니즘

⭐️ 서로 협력하여 식별자와 프로퍼티를 검색하는 데 사용된다!
```

## 19.8 오버라이딩과 프로퍼티 섀도잉

* **프로퍼티 섀도잉** : 상속관계에 의해 프로퍼티가 가려지는 현상
  * 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 인스턴스 프로퍼티로 추가하며 프로토타입 프로퍼티는 가려짐!
* 프로토타입 프로퍼티를 변경 또는 삭제하려면 프로토타입에 직접 접근해야 한다.

## 19.10 `instanceof` 연산자

```jsx
객체 instanceof 생성자 함수
// 우변의 피연산자가 함수가 아닌 경우 TypeError 발생!
```

* 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true, 그렇지 않은 경우 false
* instanceof 연산자는 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.

## 19.11 직접 상속

### `Object.create`에 의한 직접 상속

* `Object.create` 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.
* 다른 객체 생성 방식과 마찬가지로 추상 연산 `OrdinaryObjectCreate` 를 호출한다.
* 첫 번째 매개변수 : 생성할 객체의 프로토타입으로 지정할 객체
* 두 번째 매개변수 : 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이뤄진 객체

```jsx
/**
 * 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체를 생성하여 반환
 * @param {object} prototype - 생성할 객체의 프로토타입으로 지정할 객체
 * @param {object} [propertiesObject] - 생성할 객체의 프로퍼티를 갖는 객체
 * @returns {object} 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체
*/

Object.create(prototype[, propertiesObject])
```

* `Object.create` 의 장점
  * new 연산자 없이 객체 생성
  * 프로토타입을 지정할 수 있음
  * 객체 리터럴에 의해 생성된 객체도 상속받을 수 있음
* `Object.create` 메서드로 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있으므로 Object.prototype의 빌트인 메서드를 객체가 직접 호출하는 것을 권장하지 않는다.

### 객체 리터럴 내부에서 **proto** 에 의한 직접 상속

* ES6에서는 객체 리터럴 내부에서 **proto** 접근자 프로퍼티를 사용하여 직접상속 구현

```jsx
const obj = {
    y: 20,
    __proto__: myProto
};
```

## 19.12 정적 프로퍼티/메서드

* **`정적 프로퍼티/메서드`** 는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 말하며 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.

## 19.13 프로퍼티 존재 확인

### in 연산자

* 객체 내에 특정 프로퍼티가 존재하는지 여부 확인
* 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의 필요
* ES6에서 도입된 `Reflect.has` 도 동일하게 동작한다.

### Object.prototype.hasOwnProperty 메서드

* 객체에 특정 프로퍼티가 존재하는지 확인
* 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true 반환
* 상속받은 프로토타입의 프로퍼티 키인 경우에는 false 반환

## 19.14 프로퍼티 열거

### for ... in 문

```jsx
for (변수선언문 in 객체) { ... }
```

* 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중 \[\[Enumberable\]\] 값이 true인 경우에만 열거됨
* 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않음
* 순서를 보장하지 않는 것이 원칙
* 그러나 대부분의 모던 브라우저는 순서를 보장하고 숫자\(문자열이지만\)인 키는 정렬 실시

### Object.keys/values/entries 메서드

* 객체 자신의 고유 프로퍼티만 열거하기 위해서는 `for ... in` 문 보다는 Object.keys/values/entries 메서드를 사용하는 것을 권장한다.

