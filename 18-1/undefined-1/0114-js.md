# 자바스크립트는 왜 그 모양일까? 7장 ~ 9장 \(81p ~ 122p\)

> 저자 : 더글러스 크락포드   
>  1월 3주차 기록 \(읽은 날짜 1월 14일\)

## 7장. 배열

* JS의 첫 배포 당시에는 배열이 존재하지 않았다.
* `typeof` 연산자는 배열에 대해 `object`를 리턴한다. 배열이 배열인지 확인하기 위해서는 `Array.isArray(arr)`를 사용해야 한다.
* JS의 배열이 객체와 다른 점
  1. `length` 속성을 가지고 있다. 배열이 담고 있는 요소의 개수를 의미하는 것이 아니라 가장 큰 인덱스보다 1 큰 값을 나타낸다.
  2. `Object.prototype`보다 훨씬 더 좋은 메소드들을 담고 있는 `Array.prototype`을 상속한다.
  3. 문법적으로 더 간단한 배열 리터럴을 사용하여 만들어진다. `[` `]` `,`
  4. JSON은 배열과 객체를 다르게 취급하지만 JS는 둘을 비슷하게 처리한다.

### 정렬

* 자바스크립트의 `sort` 메소드는 추가 메모리 공간을 사용하지 않고 배열 자체를 수정한다. 따라서 동결된 배열은 정렬할 수 없으며 공유 중인 배열을 정렬하는 것은 위험한다. 또한 값이 숫자일지라도 문자열처럼 정렬한다.

```javascript
array = [11, 2, 23, 13, 3, 5, 17, 7, 29, 19];
array.sort(); // [11, 13, 17, 19, 2, 23, 29, 3, 5, 7]
```

* 비효율적일 뿐만 아니라 잘못된 동작이다. sort 메소드에 비교 함수를 전달하여 원하는 대로 결과가 나오게끔 한다.
  * 0번째 요소가 앞쪽에 가야 할 때 음수
  * 1번째 요소가 앞쪽에 가야 할 때 양수
  * 어느 쪽이 앞쪽으로 가야 할지 알 수 없을 때 0

```javascript
function compare(first, second) {
    return first - second;
}
```

* `sort` 함수의 또 다른 문제점은 **안정성의 부족**이다. 배열의 두 요소를 비교했을 때 비교함수가 0을 반환하는 경우 두 요소의 상대적인 위치를 그대로 유지한다면 안정적일 것이다. 그러나 JS는 안정성을 보장하지 않는다. 더 복잡한 비교함수를 만들어 이 문제를 해결해야 한다.

## 8장. 객체

* 자바스크립트는 `null`과 `undefined`를 제외한 모든 것을 객체로 취급한다.
* 객체는 JS의 기본 데이터 구조이다.
* 다른 언어에서는 해시 테이블, 맵, 레코드, 구조체, 딕셔너리, dict 라고도 불린다.
* 존재하지 않는 값은 `undefined`를 반환한다.
* 객체에는 `undefined`를 할당하지 않는 것이 좋다. **그 속성이 해당 객체에 없는 것이 아니기 때문**

### 상속

* JS에서 객체는 다른 객체를 상속받을 수 있다. 단, **데이터만 연결**된다.
* `Object.create(prototype)`은 이미 있는 객체를 전달받아 **이를 상속받는 새로운 객체를 반환**한다. 즉, 기존의 객체가 새로운 객체의 _prototype_ 이 되는 것
* 객체에 없는 속성을 참조하려 할 때 undefined를 반환하기 전에 시스템은 해당 객체의 프로토타입을 확인하고, 프로토타입의 프로토타입을 확인하는 식으로 거슬러 올라간다. 프로토타입 체인 중에 같은 이름의 속성을 발견하면, 마치 해당 객체가 가지고 있던 속성인 것처럼 값을 반환한다.
* 객체의 속성에 값을 대입하면, 프로토타입 체인의 가장 위쪽에 있는 객체만 변경된다.
* 속성의 두 가지 형태
  * 고유\(own\) 속성
  * 상속받은\(inherited\) 속성
  * `hasOwnProperty(string)` : 객체가 해당 이름의 속성을 가지고 있으며 상속받지 않는 경우 true 리턴

### 동결

* `Object.freeze(object)` : 객체를 전달받아 동결한다. -&gt; 변경할 수 없게!
* 단, deep freeze를 보장하지 않으며 오직 최상위 객체만 동결된다.
* 불변 객체는 시스템의 신뢰성을 높여주고, 보안 면에서 훌륭하다.

### WeakMap

* 객체의 속성을 객체나 배열로 쓰고 싶을 때 `toString` 메소드를 쓸 수 있지만 좋지 않다.
* `weakMap`은 문자열을 제외한 다른 객체를 키로 쓴다.
* 객체와 비밀 키에 모두 접근할 수 있어야 내용을 볼 수 있다. \(보안성\)
* 봉인자\(sealer\) : 봉인자에 객체를 전달하면 열 수 없는 상자를 반환한다.
* 개봉자\(unsealer\) : 원래 객체로 복구
* `WeakMap`은 키를 가지고 있지 않는 한 값을 볼 수 없다. 키의 사본이 존재하지 않는 경우 해당 키의 속성은 자동으로 삭제된다. \(가비지 컬렉터\)

## 9장. 문자열

* 문자열은 0에서 65535 사이의 크기를 가지는 부호가 없는 16비트 정수로 이루어진 불변 배열, 항상 동결된 상태이므로 요소는 변경되지 않음.
* `String.fromCharCode(num)` : 문자열을 생성할 수 있는 함수

### 더 많은 유니코드

* 유니코드의 목적 : 세상에 존재하는 모든 언어를 16비트로 표현 =&gt; 21비트로 표현
* JS는 유니코드가 16비트로 표현하려던 시절에 설계됨.
* JS에는 1024개의 상위 대리 코드 유닛과 1024개의 하위 대리 코드 유닛이 있다. 상위 유닛이 하위 유닛보다 더 낮은 코드 값을 가진다. \(OxD800 ~ 0xDBFF \| 0xDC00 ~ 0xDFFF\)
* 예시 : U+1F4A9\(128169\) =&gt; 65,536을 뺀 62,644을 얻는다. 상위 10비트는 0x03D고 하위 10비트는 0x0A9 =&gt; 상위 비트에 0xD800을 더하고 하위 비트에 0xDC00을 더하여 대리 쌍을 얻는다.

