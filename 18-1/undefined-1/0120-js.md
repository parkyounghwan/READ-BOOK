# 자바스크립트는 왜 그 모양일까? 13장 ~ 17장 \(143p ~ 176p\)

> 저자 : 더글러스 크락포드   
>  1월 4주차 기록 \(읽은 날짜 1월 20일\)

## 13장. 제너레이터

* ES6부터 제너레이터 기능이 도입되었음
* 제너레이터는 `function*`로 만들어진 `next` 메소드를 포함하는 함수 객체를 만듦
* 제너레이터는 실행 흐름을 멈추거나 재개할 수 있어 실행 흐름이 복잡해진다.

### 더 나은 방법

```javascript
function factory(factory-params) {
    // initialize the generator's state
    return function generator(gen-params) {
        // update the state
        return value;
    }
}
```

* 제너레이터의 상태는 factory 변수에 저장됨

#### 예시

```javascript
// 값을 인자로 받고 항상 그 값을 반환하는 제너레이터
function constant(val) {
    return function const_generator() {
        return value;
    }
}
```

```javascript
// 호출될 때마다 그다음 정수를 반환하고 마지막에는 undefined를 반환
function integer(from = 0, to = Number.MAX_SAFE_INTEGER, step = 1) {
    return function() {
        if (from < to) {
            const result = from;
            from += step;
            return result;
        }
    }
}
```

```javascript
// 배열을 전달받아서 호출될 때마다 배열의 각 요소를 반환하는 제너레이터
function element(array, gen = integer(0, array.length)) {
    return function ele_generator(...args) {
        const element_nr = gen(...args);
        if (element_nr !== undefined) {
            return array[element_nr];
        }
    }
}
```

```javascript
// 객체의 모든 속성을 키와 값으로 구성된 배열로 반환
function property(obj, gen = element(Object.keys(object))) {
    return function prop_generator(...args) {
        const key = gen(...args);
        if (key !== undefined) {
            return [key, object[key]];
        }
    }
}
```

```javascript
function filter(generator, predicate) {
    return function filter_gen(...args) {
        const value = generator(...args);
        if (value !== undefined && !predicate(value)) {
            return filter_gen(...args);
        }
        return value;
    }
}

const my_third_array = harvest(filter(
    interger(0, 42),
    function divisible_by_three(value) {
        return (value % 3) === 0;
    }
))
```

* 제너레이터는 순수 함수와 비순수 함수 사이의 경계에 있음
* 대부분의 제너레이터는 완벽하게 **비순수 함수임**
* 제너레이터는 상태를 가지고 있을 수도 있지만 상태 정보는 팩토리 클로저에 숨겨져 있음

## 14장. 예외

* 호출한 함수가 예상치 못한 방식으로 문제를 일으킬 수 있다 =&gt; `예외 처리`의 필요성
* 자바스크립트의 예외 처리 방법은 Java에서 영감을 받았다. Java는 C++에서 받았다.
* JS에서 문제가 생기면 `throw` 문을 통해 신호가 발생된다. Error 생성자로 만든 값을 던지는 게 일반적이기는 하지만 필수는 아니다. throw에 어떤 값이든 허용한다.
* 예외 핸들러 `catch`는 throw 문이 던진 단 한 개의 인자만 받을 수 있다.
* 하나의 함수에서 `try`를 두 번 이상 쓰지 않도록 주의해야 한다.

### 되감기

* 예외처리가 신경 써야 할 점 중 하나는 **제대로 동작하는 프로그램에서는 성능 패널티가 없어야 한다**는 것이다.
* 자바스크립트 컴파일러는 컴파일하는 모든 함수에 대한 캐치맵을 만든다. 캐치맵은 함수 몸체의 명령어 위치와 이들을 처리하는 `catch`문을 연결해준다. `throw`문이 실행되면 예외가 발생하고 현재 함수에 대한 캐치맵을 참조한다.
* `catch`절을 찾을 때까지 가상의 호출 스택을 타고 내려가다가 더 이상 스택이 없으면 예외가 된다.

### 일상적인 예외

* 실행 흐름은 예외 객체를 만들어 낸 메서드에 의해 결정된다.
* 자바스크릡트의 타입 시스템은 유연해서 예상할 수 있는 모든 상황을 처리하기에 충분하다.
* `return`을 써야 하는 자리에 `throw`를 쓰지 말자.

### 비동기 프로그래밍에서의 예외 처리

* 예외 처리는 스택을 거꾸로 되감으면서 진행된다. 예외로 발생한 값은 스택의 더 아래쪽에 있는 함수 호출로 전달된다.
* 비동기 플그래밍에서 스택은 매 회 비워진다. 그래서 더 이상 존재하지 않는 스택을 거슬러 가서 예외 값을 전달할 수 없다.

## 15장. 프로그램

* 자바스크립트 엔진은 자바스크립트 소스 코드를 컴파일해서 기계어나 중간 언어, 혹은 둘 다로 변환한다. 그래서 자바스크립트는 이식성이 아주 뛰어나다.
* 자바스크립트 컴파일러는 프로그램의 중요한 보안 관련 속성을 쉽고 빠르게 확인할 수 있다.
* 자바스크립트 코드는 여러 단위로 나눠진다. 대개 `.js` 파일이지만 JSON 객체의 소스 문자열이 될 수도 있고, DB에 저장될 수도 있다.
* 각 소스 단위는 매개변수 없는 함수의 몸체처럼 다룬다. 함수처럼 컴파일되어 호출된다.
* 각 소스 단위에서 프로그램 실행이 끝날 수도 있다. 하지만 JS 코드는 일반적으로 이벤트나 메시지를 전달받으면 실행되도록 등록되거나, 혹은 다른 곳에서 사용할 수 있도록 export하는 데 많이 사용된다.
* 모든 소스 단위에 자동으로 만들어지는 객체와 함수들이 있다.

### 전역 변수

* 전역 스코프에는 `window` 변수와 페이지 스코프에 대한 참조가 포함된 `self` 변수가 있다.
* 페이지 스코프에 있는 모든 변수는 해당 페이지에서 사용하는 모든 소스 단위에서 볼 수 있다. -&gt; 보안 취약점이 발생!
* _전역 변수는 악의 근원이다._

### 모듈

* 함수 바깥에 변수를 선언하는 더 좋은 방법은 `모듈 스코프`에 선언하는 것이다. 모듈 스코프의 변수들은 해당 소스 유닛에 있는 함수들만 볼 수 있다.
* 다른 소스 단위와 함께 쓰려면 `import` `export` 문을 써서 명시적으로 하게 된다.
* `export`는 일종의 인터페이스로, 인터페이스는 간단하고 명료해야 한다.
* 소스 유닛의 코드 몸체는 한 번만 실행된다. **임포트하는 여러 주체들은 동일한 익스포트 내용을 공유한다는 것이다.**
* import 문은 파일 최상단에, export 문은 가장 아래에 쓰는 것이 좋다.

### 응집도\(Cohesion\)와 결합도\(Coupling\)

* 미시적 수준에서 좋은 프로그래밍이란 좋은 코딩 규칙에 달려 있다.
* 거시적 수준에서 좋은 프로그래밍은 좋은 모듈 설계에 달려 있다.
* 좋은 모듈은 응집도가 높다. 즉, 모듈의 모든 요소가 어우러져 하나의 목적을 이루기 위해 함께 동작한다.
* 나쁜 모듈은 구조가 좋지 않고, 모듈에서 너무 많은 일을 하려다 보니 응집도가 낮다.
* 좋은 모듈은 약하게 결합되어 있다.
* 나쁜 모듈은 강하게 결합되어 있다. 상호 의존적인 모듈은 서로를 강하게 결합할 수 밖에 없다.
* **모듈 인터페이스를 간단 명료하게 만들어라. 의존성을 최소화하라.**

## 16장. this

* 많은 객체가 같은 프로토타입을 공유할 수 있다. 이런 객체들은 클래스 인스턴스처럼 보일 수 있지만, 실은 프로토타입을 공유하는 개별적인 객체에 불과하다.
* 프로토타입을 사용하는 가장 큰 이유 중 하나는 메소드를 저장하는 공간으로 쓰기 위함이다. -&gt; 메모리의 절약
* 객체에 메소드가 발견되면 인자 목록을 건네 메소드를 호출한다. 메소드는 자신을 동작시킨 객체에 대한 정보를 `this`라는 묵시적 매개변수로 전달받는다.
* `this`는 동적으로 바인딩된다는 점에서 독특하다.
* `this`는 보안이나 신뢰성 위험을 초래할수 있다.
* 모든 변수는 정적으로 바인딩된다. 오직 `this`만이 동적으로 바인딩되며, 함수를 만든 쪽이 아닌 호출하는 쪽이 this 바인딩을 결정한다.
* 함수 객체는 두 개의 프로토타입 속성을 가지고 있다.
  1. `Function.prototype`에 대한 delegation 링크
  2. `new` 접두어로 함수가 호출된 경우 생성된 객체의 프로토타입으로 사용된 객체에 대한 참조를 `prototype`이라는 속성으로 가지게 된다.

### new 접두사가 하는 일

1. Object.create\(function.prototype\)에 대한 this 값 생성
2. 새로운 객체에 바인딩된 this 값으로 함수를 호출
3. 함수가 객체를 반환하지 않으면 this를 강제로 반환
4. `new` 접두사를 써서 호출해야 하는 생성자 함수는 반드시 대문자로 시작해야 한다. 그 외의 다른 함수들은 대문자로 시작해서는 안 된다.
5. class 문법은 클래스를 구현하는 것이 아니라 JS 생성자의 이상함을 감추고 문법을 쉽게 이용하게 만든다.

## 17장. 클래스 없는 자바스크립트

* 상속은 아주 강력한 코드 재사용 기법이다. `거의 같지만, 예외가 있다`라는 생각에 기초를 두고 있다.
* 프로그램이 복잡해지면서, 상속은 많은 문제를 일으켰다. 클래스 사이의 강한 결합도를 유발한다.
* 클래스 때문에 객체 그 자체가 아닌 객체의 속성에 너무 많은 주의를 기울인다.

### 생성자

```javascript
function count() {
    let counter = 0;

    function up() {
        counter += 1;
        return counter;
    }

    function down() {
        counter -= 1;
        return counter;
    }

    return Object.freeze({
        up,
        down
    });
}
```

* 객체는 자신만의 상태를 가진다. `counter` 변수는 객체의 private 속성이다.
* 객체를 보호하는 아주 좋은 방법은 캡슐화 방법이다. 데이터에 직접 접근하지 않도록 한다.
* 생성자는 객체를 반환하는 함수이다. 생성자의 매개변수와 변수는 객체의 private 속성이 된다.
* 메서드는 트랜잭션으로 구현되어야 한다.
* 객체는 두 가지 종류로 볼 수 있다.
  * hard object : 메서드만 가짐, 클로저 내부에 있는 데이터에 대한 완전성 보호, 다형성과 캡슐화 제공
  * soft data object : 정의된 동작이 없음, 함수에 의해 처리될 수 있는 데이터 집합

### 생성자 매개변수

* **객체로 매개변수를 전달하라**
* key 문자열 값이 코드 자체를 문서화해준다.
* 인자가 어떤 순서로 전달되어도 관계 없다.
* 기존의 코드를 수정하지 않고도 새로운 인자를 추가할 수 있다.
* 쓸모없는 매개변수는 무시된다.

### 컴포지션

* 생성자는 원하는 상태 관리나 동작을 쓰기 위해서 원하는 만큼 다른 생성자를 호출해서 쓸 수 있다.
* 동일한 객체를 다른 생성자에 전달할 수도 있다.

### 크기

* 모든 객체의 메서드를 가지고 있는 것과 프로토타입 객체를 사용하는 것에 메모리 차이는 크게 없다.
* 오히려 모듈화에서 더 큰 이득을 얻을 수 있다.

