# I/O \(Input & Output\)

* Java 에서의 I/O 는 JVM 을 기준으로 한다.
* JVM 이 읽는 작업을 하는 게 'Input' / JVM 이 쓰는 작업을 하는 것이 'Output'

## Buffer

* 예를들어, 문자열 데이터를 주고 받을 때, 한 문장 씩 나눠서 주고 받고 하면 문장마다 I/O 가 발생해서 많은 리소스가 투입이 될 것이다. 해당 문자열을 JVM 이 전부 읽어들여서 필요한 곳에 전송 할 수 있다면, 효과적으로 리소스를 사용할 수 있다.

## Reader/Writer

* 자바에서 char 기반의 문자열을 처리하기 위한 클래스
* Stream 관련 클래스는 byte 를 처리하기 위한 클래스

### Writer

* 'Writer' 클래스가 제공하는 write\(\), append\(\) 메소드는 호출 될 때 마다 파일에 쓰기 때문에 매우 비효율적
* 따라서, 쓰려고 하는 데이터를 모두 모아서 한번에 파일에 써줄 수 있는 'BufferedWriter' 를 제공

## Serialize

* 텍스트 파일로 객체를 쓰고/읽는 행위에 대해서 생각해보자. 클래스로 생성한 객체에 대해서, 각 필드의 값을 채우고 File I/O 클래스를 이용해서 클래스의 인스턴스를 binary 로 변환하여 File에 쓴다. binary 로 변환된 인스턴스가 텍스트 파일에 써져있을 것이다. 썼던 파일의 binary 를 다시 읽어서, 전달에 사용된 클래스의 새로운 인스턴스를 생성해서 매핑해보면 정상적으로 객체가 생성되는 것을 확인 할 수 있다.
* 별 다른 변화가 없다면, 주고 받는 행위에 대해서 따로 고려해야 할 것이 없어보인다.
* 하지만 만약, 클래스의 필드명이 변경된다면 어떻게 될까? 클래스에 새로운 필드를 추가하고, 파일에 쓰여진 데이터를 다시 읽어보자. 아마도 에러가 발생할 것이다.
* JVM 에서 읽어들일 때, 변경된 클래스에 매핑되지 못하므로 에러가 발생한다.
* 이렇게 객체가 다르게 될 경우를 확인하기 위해서, 자바에서는 'Serializable' 클래스를 제공한다.
* 서로 다른 JVM 이나, 서버에서 클래스의 이름이 같더라도 'Serializable' 인터페이스를 구현한 클래스의 'serialVersionUID' 가 다를 경우 같은 객체로 인식하지 않는다.
* 따라서, 클래스의 변경이 일어날 경우에 해당 클래스의 'serialVersionUID' 도 수정해 주어야 한다. 정리하자면 'Serializable' 인터페이스를 구현한 클래스가 변경 될 때. 'serialVersionUID' 또한 변경해주는 습관을 들여야 한다.
* 그렇다면, 이런 번거로운 작업을 계속 수행해야 하는 것일까?

