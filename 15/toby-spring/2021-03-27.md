# 2021-03-27

**애노테이션: @Autowired / @Inject**

`@Autowired` 는 스프링 2.5부터 적용된 스프링 전용 애노테이션이고 `@Inject` 는 JavaEE 6의 표준 스펙인 JSR-330에 정의되어 있는 것으로, 스프링 외에도 JavaEE 6의 스펙을 따르는 여타 프레임워크에서도 동일한 의미로 사용되는 DI를 위한 애노테이션이다. 스프링으로 개발한 POJO를 앞으로 다른 환경에서도 사용할 가능성이 있다면 `@Inject` 와 DIJ에서 정의한 애노테이션을 사용하는게 좋다.

`@Autowired` 는 XML의 타입에 의한 자동와이어링 방식을 생성자, 필드, 수정자 메소드, 일반 메소드의 네가지로 확장한 것이다.

* **수정자 메소드와 필드**

  `@Autowired` 애노테이션이 부여된 필드나 수정자를 만들어주면 스프링이 자동으로 DI해준다.

* **생성자**

  생성자의 모든 파라미터에 타입에 의한 자동와이어링이 적용된다. 단 하나의 생성자에만 사용할 수 있다.

* **일반 메소드**

  파라미터를 가진 메소드를 만들고 `@Autowired` 를 붙여주면 각 파라미터의 타입을 기준으로 자동와이어링을 해서 DI 해줄 수 있다. 생성자 주입과 달리 일반 메소드는 오브젝트 생성 후에 차례로 호출이 가능하므로 여러 개를 만들어도 된다. 한 번에 여러 개의 오브젝트를 DI할 수 있으므로 코드도 상대적으로 깔끔 해진다.

* **컬렉션과 배열**

  `@Autowired` 를 이용하면 같은 타입의 빈이 하나 이상 존재할 때 그 빈들을 모두 DI 받도록 할 수 있다. `@Autowired` 의 대상이 되는 필드나 프로퍼티, 메소드의 파라미터를 컬렉션이나 배열로 선언하면 된다.

  컬렉션과 배열을 단지 같은 타입의 빈이 여러 개 등록되는 경우에 충돌을 피하려는 목적으로 사용해서는 안 된다. 의도적으로 타입이 같은 여러 개의 빈을 등록하고 이를 모두 참조하거나 그중에서 선별적으로 필요한 빈을 찾을 때 사용하는 것이 좋다.

  DI 할 빈의 타입이 컬렉션인 경우에는 `@Autowired` 로 자동 설정이 불가능하다. 빈 자체가 컬렉션인 경우에는 `@Resource` 를 이용해야 한다.

* **@Qualifier**

  타입 외의 정보를 추가해서 자동와이어링을 세밀하게 제어할 수 있는 보조적인 방법이다.

  빈 이름과는 별도로 추가적인 메타정보를 지정해서 의미를 부여해놓고 이를 `@Autowired` 에서 사용할 수 있게 하는 `@Qualifier` 가 훨씬 직관적이고 깔끔하다.

  스프링은 `@Qualifier` 를 메타 애노테이션으로 갖는 애노테이션도 `@Qualifier` 취급을 해준다.

  ```java
    @Target({ElementType.FIELD, ElementType.PARAMETER})
    @Retention(RetentionPolicy.RUNTIME)
    @Qualifier
    public @interface Database {
        String value();
    }
  ```

  `@Qualifier` 를 이용하여 이름에 의한 빈 선택도 가능하지만 권장되지 않는다.

  `@Qualifier` 는 그 부여 대상이 필드와 수정자, 파라미터뿐이다. 생성자와 일반 메소드의 경우에는 `@Qualifier` 를 부텨하는 것이 의미가 없다. 각 파라미터마다 하나의 빈이 매핑되기 때문에 이때는 생성자나 메소드가 아니라 파라미터에 직접 `@Qualifier` 를 붙여야 한다.

  ```java
    @Autowired
    public void config(@Qualifier("mainDB") Datasource dataSource, Printer printer) {}
  ```

  `@Autowired` 는 `@Resource` 와 마찬가지로 일단 지정하면 반드시 DI 할 후보 빈이 존재해야 한다. 그렇지 않으면 빈을 찾을 수 없다는 에러가 발생한다. 컬렉션으로 선언된 경우에도 최소한 한 개의 타입이 일치하는 빈이 존재해야만 한다.

**@Autowired와 getBean\(\), 스프링 테스트**

학습코드를 만들 때 특정 타입의 빈이 하나만 존재한다면, 이름 대신 타입을 이용해서 빈을 찾을 수 있다. 같은 타입의 빈이 두 개 이상이라면 에러가 발생한다.

```java
Printer printer = ac.getBean(Printer.class);
```

`@Autowired` 과 같은 모든 애노테이션 방식의 의존관계 설정 기법을 모두 적용할 수 있다. 그렇다고 테스트 클래스가 애플리케이션 컨텍스트에 빈으로 등록되는 것은 아니다. 단지 컨텍스트의 빈 오브젝트를 테스트에서 손쉽게 사용할 수 있도록 테스트에 필요한 빈을 테스트 오브젝트의 필드에 넣어줄 뿐이다.

**자바 코드에 의한 의존관계 설정**

* 애노테이션에 의한 설정 @Autowired, @Resource

  빈은 자바 코드에 의해 생성되지만 의존관계는 빈 클래스의 애노테이션을 이용하게 할 수 있다. `@Autowired` 와 같은 애노테이션을 통한 의존관계 설정은 빈 오브젝트 등록을 마친 후에 후처리기에 의해 별도의 작업으로 진행되기 때문이다.

* @Bean 메소드 호출

  @Configuration이 붙은 클래스에서 @Bean이 붙은 메소드를 여러번 호출해도 싱글톤으로 처리되기 때문에 하나의 인스턴스만 생성된다.

* @Bean과 메소드 자동와이어링

  메소드로 정의된 다른 빈을 가져와 자바 코드로 의존 정보를 생성할 때 직접 @Bean이 붙은 메소드를 호출하는 대신 그 빈의 레퍼런스를 파라미터로 주입받는 방식

  ```java
    @Configuration
    public class Config {
    @Bean public Hello hello(Printer printer) {
            Hello hello = new Hello();
            hello.setPrinter(printer);
            return hello;
        }
    @Bean public Printer printer() {
            return new Printer();
        }
    }
  ```

  Config 클래스 내의 여러 @Bean 메소드에서 참조되는 빈 오브젝트라면, 클래스 레벨의 DI를 통해 가져와도 된다.

**빈 의존관계 설정 전략**

* **XML 단독**

  빈 등록은 물론 의존관계 설정까지 모두 XML만으로 구성하는 방법. XML 자동와이어링은 `@Autowired` 애노테이션에 비해 느리므로 가능한 한 이름에 의한 방식을 사용하는 편이 좋다.

* **XML과 애노테이션 설정의 혼합**

  빈은 XML로 등록하지만 의존관계 정보는 `@Autowired` 나 `@Resource` 같은 애노테이션을 이용하는 방법

* **애노테이션 단독**

  빈의 등록도 `@Component`애노테이션을 이용해 스캐너에게 맡기고 의존관계 역시 `@Autowired` 와 같은 애노테이션을 이용해 자동으로 등록하는 방법

