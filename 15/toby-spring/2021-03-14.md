# 2021-03-14

### **웹 애플리케이션의 컨텍스트 구성방법**

웹 애플리케이션의 애플리케이션 컨텍스트를 구성하는 방법으로는 다음 세 가지를 고려해볼 수 있다. 첫 번째 방법은 컨텍스트 계층구조를 만드는 것이고, 나머지 두 가지 방법은 컨텍스트를 하나만 사용하는 방법이다.

* 서블릿 컨텍스트와 루트 애플리케이션 컨텍스트 계층구조 : 가장 많이 사용되는 기본적인 구성방법. 스프링 웹 기술을 사용하는 경우 웹 관련 빈들은 서블릿의 컨텍스트에 두고 나머지는 루트 애플리케이션 컨텍스트에 등록한다.
* 루트 애플리케이션 컨텍스트 단일구조 : 스프링 웹 기술을 사용하지 않고 서드파티 웹 프레임워크나 서비스 엔진만을 사용해서 프레젠테이션 계층을 만든다면 스프링 서블릿을 둘 이유가 없으므로 사용하는 구조.
* 서블릿 컨텍스트 단일구조  : 스프링 웹 기술을 사용하면서 스프링 외의 프레임워크나 서비스 엔진에서 스프링의 빈을 이용할 생각이 아니라면 루트 애플리케이션 컨텍스트를 생략할 수도 있다. 대신 서블릿에서 만들어지는 컨텍스트에 모든 빈을 다 등록하면 된다. 이렇게 만들어지는 서블릿 컨텍스트는 컨텍스트 계층 관점에서 보자면 루트 컨텍스트이지만 웹 애플리케이션 레벨에 두는 공유 가능한 루트 컨텍스트와는 구별된다.

**루트 애플리케이션 컨텍스트 등록**

웹 애플리케이션 레벨에 만들어지는 루트 웹 애플리케이션 컨텍스트를 등록하는 가장 간단한 방법은 서블릿의 이벤트 리스너를 이용하는 것이다. 스프링은 웹 애플리케이션의 시작과 종료 시 발생하는 이벤트를 처리하는 리스너인 `ServletContextListener`를 이용한다.

웹 애플리케이션이시작될 때 루트 애플리케이션 컨텍스트를 만들어 초기화하고, 웹 애플리케이션이 종료될 때 컨텍스트를 함께 종료하는 기능을 가진 리스너를 만들 수 있다. 스프링은 이러한 기능을 가진 리스너인 `ContextLoaderListener`를 제공한다.

`ContextLoaderListener` 는 웹 애플리케이션이 시작할 때 자동으로 루트 애플리케이션 컨텍스트를 만들어주고 초기화해준다. 디폴트로는 아래의 값이 설정된다.

* 애플리케이션 컨텍스트 클래스: XmlWebApplicationContext
* XML 설정파일 위치: /WEB-INF/applicationContext.xml

**서블릿 애플리케이션 컨텍스트 등록**

스프링의 웹 기능을 지원하는 프론트 컨트롤러 서블릿은 `DispatcherServlet`이다.

서블릿 이름을 다르게 지정해주면 하나의 웹 애플리케이션에 여러 개의 `DispatcherServlet`을 등록할 수도 있다. 각 `DispatcherServlet` 은 서블릿이름을 다르게 지정해주면 하나의 웹 애플레케이션에 여러 개의 `DispatcherServlet` 을 등록할 수도 있다. 각 `DispatcherServlet` 은 서블릿이 초기화 될 때 자신만의 컨텍스트를 생성하고 초기화한다. 동시에 웹 애플리케이션 레벨에 등록된 루트 애플리케이션 컨텍스트를 찾아서 이를 자신의 부모 컨텍스트로 사용한다.

`DispatcherServlet`에 의해 만들어지는 애플리케이션 컨텍스트는 모두 독립적인 네임스페이스를 갖게 된다. 네임스페이스는 `<servlet-name>`으로 지정한 서블릿 이름에 -servlet을 붙여서 만든다. 서블릿 이름이 spring이라면 네임스페이스는 spring-servlet이 된다.

`<load-on-startup>`은 서블릿 컨테이너가 등록된 서블릿을 언제 만들고 초기화할지, 또 그 순서는 어떻게 되는지를 지정하는 정수값이다. 이 항목을 아예 생략하거나 음의 정수로 넣으면 해당 서블릿은 서블릿 컨테이너가 임의로 정한 시점에서 만들어지고 초기화된다. 반대로 0 이상의 값을 넣으면 웹 애플리케이션이 시작되는 시점에서 서블릿을 로딩하고 초기화한다. 또한 여러 개의 서블릿이 등록되어 있다면 작은 수를 가진 서블릿이 우선적으로 만들어진다.

`DispatcherServlet` 은 서블릿의 초기화 작업 중에 스프링 컨텍스트를 생성한다. 컨텍스트의 설정이나 환경에 문제가 있다면 컨텍스트 생성 시 대부분 확인이 가능하다.

`DispatcherServlet` 의 컨텍스트에 대한 디폴트 설정을 변경하고 싶다면 루트 애플리케이션 컨텍스트와 마찬가지로 contextConfigLocation과 contextClass를 지정해줄 수 있다. 서블릿 컨텍스트의 파라미터 선언 방법은 루트 컨텍스트와 거의 비슷하다. 파라미터의 선언에 `<context-param>` 대신 `<servlet>` 안에 있는 `<init-param>` 을 이용한다는 점만 다르다.

## IoC/DI를 위한 빈 설정 메타정보 작성

IoC 컨테이너의 가장 기본적인 역할은 코드를 대신해서 애플리케이션을 구성하는 오브젝트를 생성하고 관리하는 것이다. POJO로 만들어진 애플리케이션 클래스와 서비스 오브젝트들이 그 대상이다. 이렇게 컨테이너가 빈이라고 불리는 오브젝트를 만들고 관리하게 하는 것이 DI를 비롯한 스프링의 주요 기술을 적용하기 위한 전제조건이다.

컨테이너는 빈 설정 메타정보를 통해 빈의 클래스와 이름을 제공받는다. 빈을 만들기 위한 설정 메타정보는 파일이나 애노테이션 같은 리소스로부터 전용 리더를 통해 읽혀서 `BeanDefinition` 타입의 오브젝트로 변환된다. 이 `BeanDefinition` 정보를 IoC 컨테이너가 활용하는 것이다.

[https://t1.daumcdn.net/cfile/tistory/99DF59445B83E81E2B](https://t1.daumcdn.net/cfile/tistory/99DF59445B83E81E2B)

### 빈 설정 메타정보

`BeanDefiniton`에는 IoC 컨테이너가 빈을 만들 때 필요한 핵심 정보가 담겨 있다.

몇 가지 필수항목을 제외하면 컨테이너에 미리 설정된 디폴트 값이 그대로 적용된다.

`BeanDefiniton` 은 여러 개의 빈을 만드는데 재사용될 수 있다. 설정 메타정보가 같지만 이름이 다른 여러개의 빈 오브젝트를 만들 수 있기 때문이다. 따라서 `BeanDefiniton` 에는 빈의 이름이나 아이디를 나타내는 정보는 포함되지 않는다.

대신 IoC컨테이너에 이 `BeanDefiniton` 정보가 등록될 때 이름을 부여해줄 수 있다.

### 빈 등록 방법

**XML:  태그**

 태그를 사용하는 가장 단순하면서 강력한 설정방법. 을 이용하면 스프링 빈 메타정보의 거의 모든 항목을 지정할 수 있으므로 세밀한 제어가 가능하다.

은 다른 빈의  태그 안에 정의할 수도 있다. 이때는 의 아이디나 이름을 지정해주지 않는다. 이렇게 다른 빈의 설정 안에 정의되는 빈을 _내부 빈_ 이라고 한다.

**XML: 네임스페이스와 전용 태그**

스프링은 DI의 원리를 애플리케이션 컨텍스트 자신에게도 적용하기 때문에 애플리케이션 컨텍스트가 필요로 하는 정보도 오브젝트 형태로 만들어 컨테이너 자신에게 DI해서 사용되게 만든다. 이를 통해 컨테이너의 유연한 확장이 가능해진다.

이렇게 컨텍스트가 사용하는 설정정보를 담은 빈과 애플리케이션의 3계층에 포함되는 애플리케이션 로직을 담은 빈이 동일하게 이라는 태그를 사용해서 만들어지기 때문에 구분이 잘 안된다. 또한 매우 범용적인 의미를 가진 태그와 로 선언되기 때문에 한눈에 빈의 등록이 어떤 의도와 의미를 갖고 있는지를 파악하기 어렵다.

스프링은 이런 기술적인 설정과 기반 서비스를 빈으로 등록할 때를 위해 의미가 잘 드러나는 네임스페이스와 태그를 가진 설정 방법을 제공한다.

**자동인식을 이용한 빈 등록: 스테레오타입 애노테이션과 빈 스캐너**

빈으로 사용될 클래스에 특별한 애노테이션을 부여해주면 이런 클래스를 자동으로 찾아서 빈으로 등록해주게 할 수 있다. 이렇게 특정 애노테이션이 붙은 클래스를 자동으로 찾아서 빈으로 등록해주는 방식을 빈 스캐닝을 통한 자동인식 빈 등록기능이라고 하고, 이런 스캐닝 작업을 담당하는 오브젝트를 빈 스캐너 라고 한다.

스프링의 빈 스캐너는 지정된 클래스패스 아래에 있는 모든 패키지의 클래스를 대상으로 필터를 적용해서 빈등록을 위한 클래스들을 선별해낸다. 빈 스캐너에 내장된 디폴트 필터는 `@Component` 애노테이션이 또는 `@Component`를 메타 애노테이션으로 가진 애노테이션이 부여된 클래스를 선택하도록 되어 있다.

이를 이용하면 `@Component` 등의 애노테이션을 지정하는 것만으로도 빈 등록이 가능하다. `@Component`를 포함해 디폴트 필터에 적용되는 애노테이션을 스프링에서는 스테레오타입 애노테이션이라고 부른다.

`@Component` 외에 자동인식을 위한 애노테이션을 여러게 사용하는데는 계층별로 빈의 특성이나 종류를 나타내려는 목적도 있고, AOP의 적용 대상 그룹을 만들기 위해서이기도 하다. AOP 포인트컷 표현식을 사용하면 특정 애노테이션이 달린 클래스만을 선정할 수가 있다. 이를 이용해 특정 계층의 빈에 부가기능을 부여해줄 수도 있다.

**자바 코드에 의한 빈 등록: @Configuration 클래스의 @Bean 메소드**

오브젝트 생성과 의존관계 주입을 담당하는 오브젝트를 오브젝트 팩토리라고 불렀고, 오브젝트 팩토리의 기능을 일반화해서 컨테이너로 만든 것이 지금의 스프링 컨테이너, 즉 빈 팩토리라고 볼 수 있다.

자바 코드에 의한 빈 등록 기능은 하나의 클래스 안에 여러 개의 빈을 정의할 수 있다. 또 애노테이션을 이용해 빈 오브젝트의 메타정보를 추가하는 일도 가능하다. 그 정의를 담고 있는 클래스 자체가 자동인식 빈의 대상이 되기 대문에 XML을 통해 명시적으로 등록하지 않아도 된다.

빈 설정 메타 정보를 담고 있는 자바 코드는 `@Configuration` 애노테이션이 달린 클래스를 이용해 작성한다. 클래스에 `@Bean` 이 붙은 메소드를 정의하고 이 메소드를 통해 빈을 정의 할 수 있다.

`@Configuration` 과 `@Bean` 이 붙으면 스프링 컨테이너가 인식할 수 있는 빈 메타정보 겸 빈 오브젝트 팩토리가 된다.

스프링은 `@Bean` 이 붙은 메소드를 이용해서 빈을 만들 때, 싱글톤 빈이라면 한 개의 오브젝트만 생성이 되고 더 이상 새로운 오브젝트가 만들어지지 않도록 `@Bean` 메소드를 조작해둔다.

`@Configuration` 클래스는 빈 스캐닝을 통해 자동등록 될 수도 있다. `@Configuration` 의 메타 애노테이션에 `@Component` 가 있기 때문에 빈 스캐너의 애노테이션 필터를 통과한다.

