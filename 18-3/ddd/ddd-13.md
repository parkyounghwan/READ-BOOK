# DDD-13

이제 6장을 다 읽었다. 지금까지 이 책을 읽어오면서 불만인 점이 있다. 책의 가독성이 매우 안좋다.

책에서 다루는 내용이 어렵고 이론적인 탓도 있지만 번역 상태가 다른 책에 비해 좋지 않다. 이 책과 동시에 다른 책을 읽으니까 번역 질의 차이가 뚜렷하게 느껴진다. 다른 책에서 다루는 내용이 이 책보다 어려운데, 더 잘 읽힌다.

책을 읽을 때 안좋은 코드를 읽는 느낌이 든다. 잘 쓰여진 코드는 메소드 명만 보고 내부 구현을 유추할 수 있지만, 그렇지 않은 코드는 메소드 구현사항을 봐야하듯이 이 책은 앞 뒤 내용의 흐름이 연결되지 않아 전체적인 맥락을 통해 내가 이해한 내용이 맞는지 검증을 해야 한다.

따라서 어느정도 읽고나서 내가 이해한 내용을 정리하고, 정리한 내용을 검색을 통해 검증하는 게 필요하다고 느꼈다.

## 5장 정리

객체 간 연관관계를 합리적으로 구성하고 연관관계를 상세하게 구현하는 게 MODEL-DRIVEN DESIGN을 실현하는 데 중요하다.

한 모델이 있을 때 반드시 하나의 설계로 모델을 구현할 수 있는 것은 아니다. 대표적으로 복수 개의 설계로 펴다른 연관관계는 일대다, 다대다가 있다.

우리는 흔히 일대다 연관관계를 한 객체에서 다른 객체의 컬렉션을 가지고 있는 설계를 생각한다. 하지만 실제로 객체 내부에 컬렉션을 가지고 있지 않고, 특정한 값\(FK\)을 통해 데이터베이스에서 조회해서 일대다에 해당하는 객체 컬렉션을 가질 수도 있다.

모델을 객체로 표현하는 방법은 세 가지가 있다.

ENTITY는 연속성과 식별성을 가진다. 객체를 식별하기 위해서 **유일한 값**이 있다. **상태**는 일관성을 지키며 연속적으로 변경된다.

VALUE OBJECT는 연속성과 식별성이 없다. 즉 **값 자체**가 객체를 표현한다. 상태를 가지고 있지 않기 때문에 재활용이 가능하다.

SERVICE는 행동과 연산을 표현하는 방법이다. 즉, 상태를 가지지 않는다. 우리가 흔히 자바에서 사용하는 인터페이스를 생각하면 된다. ENTITY간 관계를 표현하는 데 상태가 필요없다면 SERVICE로 나타낼 수 있다.

SERVICE는 세 가지 계층으로 분리할 수 있는데 응용 계층, 도메인 계층, 인프라스트럭쳐 계층이다. Layered Architecture가 그렇듯이, 상위 계층은 하위 계층을 참조할 수 있지만 하위 계층은 상위 계층을 참조해서는 안된다. 양방향 참조관계를 없애기 위해 참조 방향은 중요하다.

응용 계층은 인프라스트럭처에 종속된 전체적인 비지니스 로직을 처리한다. 우리가 Spring에서 사용하는 `@Service` 는 응용계층에 해당된다.

도메인 계층은 도메인과 관련된 비지니스 로직 처리를 한다.

인프라스트럭쳐 계층은 외부 시스템과의 로직을 처리하는 계층이다. Spring Data에서 자동으로 생성되는 `@Repository`의 구현체를 생각하면 된다. `@Repository` 로 선언되는 인터페이스 자체는 도메인 계층이라고 한다.

이 부분에 대해서 보충 설명을 하면, 도메인 계층과 인프라스트럭쳐 계층은 `JPA` 와 `Hibernate` 를 생각하면 된다.

도메인 서비스는 JPA 표준을 명세한 인터페이스이다. 인프라스트럭쳐 서비스는 인터페이스를 구현하는 구현체인 Hibernate이라고 생각하면 된다.

인프라스트럭쳐 계층에서 도메인 계층에 의존을 가지지만, 도메인 계층에서는 인프라스트럭쳐 계층에 의존을 가지지 않으므로 언제나 인프라스트럭쳐 계층에 속하는 구현체를 변경할 수 있다.

우리가 자바에서 패키지로 구분하는 모듈 또한 모델 요소이다. 모듈 간에는 결합도가 낮아야 하고, 모듈 내에는 응집도가 높아야 한다. 우리가 객체를 어떻게 만들까를 고민하듯이 모듈을 어떻게 분리할지도 고민해야 한다.

잘 설계된 코드는 구현 내용을 볼 필요가 없다. 코드 자체가 의미를 가지게 된다. 코드를 읽는 비용을 줄어들게 한다 여기에서 코드에 속하는 게 메소드, 클래스, 그리고 모듈이다. 우리가 코드를 리팩토링 하듯이 모듈도 리팩토링 해야 한다. 모듈이 잘 설계되면 MSA 서비스로 분리하는 데도 비용이 적게 든다.

프레임워크를 사용하면 모듈 경계가 강제되는 경우가 있다. 예를 들면, 스프링 부트로 웹 프로젝트를 하게 되면 나도 모르게 Controller, Service, Repository로 모듈을 나누게 된다.

